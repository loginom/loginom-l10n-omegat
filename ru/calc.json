{
  "CryptFunctions": {
    "CRC32": {
      "Arguments": "Строка - строка, для которой рассчитывается CRC32 значение.",
      "Description": "CRC32(Строка)",
      "Output": "Функция возвращает число - значение CRC32, рассчитанное от заданной строки.\nРасчеты производятся над последовательностью символов Строки в кодировке UTF-8."
    },
    "HardKey": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "HardKey()",
      "Output": "Функция возвращает серийный номер электронного ключа."
    },
    "MD5": {
      "Arguments": "Строка - строка, для которой рассчитывается MD5 значение.",
      "Description": "MD5(Строка)",
      "Output": "Функция возвращает HEX значение MD5, рассчитанное от заданной строки.\nРасчеты производятся над последовательностью символов Строки в кодировке UTF-8."
    },
    "SHA1": {
      "Arguments": "Строка - строка, для которой рассчитывается SHA1 значение.",
      "Description": "SHA1(Строка)",
      "Output": "Функция возвращает HEX значение SHA1, рассчитанное от заданной строки.\nРасчеты производятся над последовательностью символов Строки в кодировке UTF-8."
    }
  },
  "Functions": {
    "Abs": {
      "Arguments": "Аргумент - числовое выражение.",
      "Description": "Abs(Аргумент)",
      "Output": "Возвращает модуль аргумента."
    },
    "AbsErr": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "AbsErr(Аргумент1, Аргумент2)",
      "Output": "Возвращает абсолютную погрешность двух аргументов."
    },
    "AddDay": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddDay(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество дней. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество дней раньше указанной даты."
    },
    "AddMonth": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddMonth(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество месяцев. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество месяцев раньше указанной даты.\n\nЕсли указанный день месяца больше, чем последний день получившегося месяца, то функция устанавливает дату на последний день получившегося месяца."
    },
    "AddQuarter": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddQuarter(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество кварталов. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество кварталов раньше указанной даты.\n\nЕсли указанный день месяца больше, чем последний день месяца получившегося квартала , то функция устанавливает дату на последний день месяца получившегося квартала."
    },
    "AddWeek": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddWeek(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество недель. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество недель раньше указанной даты."
    },
    "AddYear": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddYear(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество лет. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество лет раньше указанной даты."
    },
    "AMGD": {
      "Arguments": "Аргументы - числовые выражения.",
      "Description": "AMGD(Стоимость, Остаточная_стоимость, Время_эксплуатации, Период)",
      "Output": "Возвращает годовую амортизацию имущества для указанного периода."
    },
    "ArcCos": {
      "Arguments": "Значение - значение косинуса, для которого необходимо найти угол.",
      "Description": "ArcCos(Значение)",
      "Output": "Возвращает арккосинус значения, т.е. угол в радианах, косинус которого равен Значение."
    },
    "ArcSin": {
      "Arguments": "Значение - значение синуса, для которого необходимо найти угол.",
      "Description": "ArcSin(Значение)",
      "Output": "Возвращает арксинус значения, т.е. угол в радианах, синус которого равен Значение."
    },
    "ArcTan": {
      "Arguments": "Значение - значение тангенса, для которого необходимо найти угол.",
      "Description": "ArcTan(Значение)",
      "Output": "Возвращает арктангенс значения, т.е. угол в радианах, тангенс которого равен Значение."
    },
    "AutoRegression": {
      "Arguments": "C - постоянная,\nA0 ... An - коэффициенты регрессии,\nX(t) ... X(t-n) - значения ряда.",
      "Description": "AutoRegression(C, A0, X{t}, A1, X{t-1} ...)",
      "Output": "Применяется для построения пользовательской модели авторегрессии вида\nПрогноз = С + A0 * X(t) + A1 * X(t-1) + ..."
    },
    "Avg": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "Avg(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает среднее арифметическое аргументов."
    },
    "Chr": {
      "Arguments": "Аргумент - числовой код символа Unicode.",
      "Description": "Chr(Аргумент)",
      "Output": "Возвращает символ Unicode по его коду."
    },
    "Concat": {
      "Arguments": "Строка - строковое выражение.",
      "Description": "Concat(Строка, Строка [, ... Строка])",
      "Output": "Объединяет несколько строк в одну.\nПропущенные значения интерпретируются как строки с нулевой длиной, т.е. как \"\"."
    },
    "Cos": {
      "Arguments": "Угол - значение угла в радианах.",
      "Description": "Cos(Угол)",
      "Output": "Возвращает косинус заданного угла."
    },
    "Count": {
      "Arguments": "Строка - строковое выражение.",
      "Description": "Count(Строка)",
      "Output": "Возвращает количество символов в строке."
    },
    "CreateGUID": {
      "Arguments": "Формат - способ строкового представления GUID (\"N\", \"D\", \"B\", \"P\").\nВерхнийРегистр - аргумент логического типа, определяющий регистр символов шестнадцатеричных цифр.",
      "Description": "CreateGUID([Формат = \"B\", ВерхнийРегистр = True])",
      "Output": "Функция возвращает строковое представление GUID в указанном формате:\n  \"N\" - 32 цифры;\n  \"D\" - 32 цифры, разделенные дефисами;\n  \"B\" - 32 цифры, разделенные дефисами и заключенные в фигурные скобки;\n  \"P\" - 32 цифры, разделенные дефисами и заключенные в круглые скобки.\nЕсли формат не указан, то используется формат \"B\". По умолчанию шестнадцатеричные цифры записываются в верхнем регистре.\nТак как GUID будет генерироваться каждый раз при получении значения выражения, например, при просмотре результата в виде таблицы или при выполнении экспорта данных, то в общем случае рекомендуется при наличии параметра выражения \"Кэшировать\" включить эту опцию."
    },
    "CumulativeSum": {
      "Arguments": "ИмяПоля - поле, по которому необходимо получить накапливающуюся сумму\nИмяПоляГруппы - поле, по которому происходит группировка данных. Этот параметр не является обязательным. Если этот параметр указан, то накапливающиеся суммы считаются в пределах групп.",
      "Description": "CumulativeSum(\"ИмяПоля\" [, \"ИмяПоляГруппы\"])",
      "Output": "Функция возвращает накапливающуюся сумму по полю.\nПримечание: ИмяПоля и ИмяПоляГруппы - строковые значения, т.е. явно заданные ИмяПоля и ИмяПоляГруппы должны быть указаны в кавычках.\nНапример: CumulativeSum(\"COL1\", \"COL2\")"
    },
    "DamLevDist": {
      "Arguments": "Строка1,\nСтрока2 - выражения строкового типа.",
      "Description": "DamLevDist(Строка1, Строка2)",
      "Output": "Функция возвращает значение расстояния Дамерау-Левенштейна для строк Строка1, Строка2. Расстояние Дамерау-Левенштейна также называют расстоянием редактирования с учетом перестановок, которое является мерой похожести двух строк. Результат - это минимальное количество операций удалений, вставки, замены и перестановок символов, которое нужно произвести, чтобы преобразовать одну строку в другую."
    },
    "Data": {
      "Arguments": "ИмяПоля - имя поля, данные которого необходимо получить\nНомерСтроки - номер строки, значение которой необходимо получить. Нумерация строк начинается с 0.",
      "Description": "Data(\"ИмяПоля\",НомерСтроки)",
      "Output": "Функция возвращает значение поля ИмяПоля взятое из строки НомерСтроки.\nПри рекурсивном использовании данной функции необходимо в окне \"Параметры выражения\" установить флаг \"Кэшировать рассчитанные значения выражения\".\nПримечание: ИмяПоля - строковое значение, т.е. явно заданное ИмяПоля должно быть указано в кавычках.\nНапример: Data(\"COL1\", 2)"
    },
    "DateTimeToStr": {
      "Arguments": "Дата_время - выражение типа дата/время.\nФормат_даты - необязательный параметр формат даты в терминах D, M, Y.\nФормат_времени - необязательный параметр формат времени в терминах H, N, S, Z.",
      "Description": "DateTimeToStr(Дата_время [, Формат_даты [, Формат_времени]])",
      "Output": "Возвращает строковое представление аргумента Дата_время.\nПримеры формата даты:\n  \"DD.MM.YY\" - преобразует дату в формат \"день.месяц.год\" (\"25.12.04\")\n  \"MM/DD/YYYY\" - преобразует дату в формат \"месяц.день.год\" (\"12/25/2004\")\nПримеры формата времени:\n  \"H:NN\" - преобразует время в формат \"часы:минуты\" (\"9:53\")\n  \"HH:NN:SS\" - преобразует время в формат \"часы:минуты:секунды\" (\"09:05:53\")"
    },
    "DateToStr": {
      "Arguments": "Дата - выражение типа дата/время.\nФормат - необязательный параметр формат даты в терминах D, M, Y.",
      "Description": "DateToStr(Дата [, Формат])",
      "Output": "Возвращает строковое представление аргумента Дата.\nПримеры формата даты:\n  \"DD.MM.YY\" - преобразует дату в формат \"день.месяц.год\" (\"25.12.04\")\n  \"MM/DD/YYYY\" - преобразует дату в формат \"месяц.день.год\" (\"12/25/2004\")"
    },
    "Day": {
      "Arguments": "Дата - поле типа дата.",
      "Description": "Day(Дата)",
      "Output": "Возвращает день по заданной дате."
    },
    "DayOfWeek": {
      "Arguments": "Дата - поле типа дата.",
      "Description": "DayOfWeek(Дата)",
      "Output": "Возвращает день недели заданной даты."
    },
    "DaysBetween": {
      "Arguments": "Дата1, Дата2 - поля типа дата.",
      "Description": "DaysBetween(Дата1, Дата2)",
      "Output": "Возвращает полное количество дней между двумя датами."
    },
    "Decode": {
      "Arguments": "Выражение - выражение, значение которого поочередно сравнивается со значениями аргументов ЗначениеN.\nЗначениеN - выражение, величина которого сравнивается с аргументом Выражение.\nРезультатN - выражение строкового типа, которое возвращается, если Выражение = ЗначениеN.\nЗначение_по_умолчанию - выражение строкового типа, результат которого возвращается, если Выражение не равно ни одному из ЗначениеN (если не указано, то равно \"\").",
      "Description": "Decode(Выражение, Значение1, Результат1 [, Значение2, Результат2]... [, Значение_по_умолчанию = \"\"])",
      "Output": " Реализует функциональность IF - THEN - ELSE, при этом результат функции имеет строковый тип.\n Все выражения РезультатN вычисляются до сравнения Выражения с ЗначениеN."
    },
    "DecodeF": {
      "Arguments": "Выражение - любое числовое выражение, величина которого используется для сравнения.\nПогрешность - числовое выражение, погрешность сравнения.\nЗначениеN - числовое выражение, величина которого сравнивается с аргументом Выражение.\nРезультатN - значение, которое возвращается, если |ЗначениеN - ВыражениеN| <= Погрешность.\nЗначение_по_умолчанию - числовое выражение, результат которого возвращается, если ни одно ЗначениеN не равно Выражению (по умолчанию 0).",
      "Description": "DecodeF(Выражение, Погрешность, Значение1, Результат1 [, Значение2, Результат2]... [, Значение_по_умолчанию = 0])",
      "Output": " Реализует функциональность IF - THEN - ELSE, при этом результат функции, также как и все ее аргументы, имеют числовой тип или тип Дата/Время.\n Все выражения РезультатN вычисляются до сравнения Выражения с ЗначениеN."
    },
    "DecodeN": {
      "Arguments": "Выражение - выражение, значение которого поочередно сравнивается со значениями аргументов ЗначениеN.\nЗначениеN - выражение, величина которого сравнивается с аргументом Выражение.\nРезультатN - выражение числового типа или типа Дата/Время, которое возвращается, если Выражение = ЗначениеN.\nЗначение_по_умолчанию - выражение числового типа или типа Дата/Время, результат которого возвращается, если Выражение не равно ни одному из ЗначениеN (если не указано, то равно 0).",
      "Description": "DecodeN(Выражение, Значение1, Результат1 [, Значение2, Результат2]... [, Значение_по_умолчанию = 0])",
      "Output": " Реализует функциональность IF - THEN - ELSE, при этом результат функции имеет числовой тип или тип Дата/Время.\n Все выражения РезультатN вычисляются до сравнения Выражения с ЗначениеN."
    },
    "DecodeS": {
      "Arguments": "Выражение - выражение, значение которого поочередно сравнивается со значениями аргументов ЗначениеN.\nЗначениеN - выражение, величина которого сравнивается с аргументом Выражение.\nРезультатN - выражение строкового типа, которое возвращается, если Выражение = ЗначениеN.\nЗначение_по_умолчанию - выражение строкового типа, результат которого возвращается, если Выражение не равно ни одному из ЗначениеN (если не указано, то равно \"\").",
      "Description": "DecodeS(Выражение, Значение1, Результат1 [, Значение2, Результат2]... [, Значение_по_умолчанию = \"\"])",
      "Output": " Реализует функциональность IF - THEN - ELSE, при этом результат функции имеет строковый тип.\n Все выражения РезультатN вычисляются до сравнения Выражения с ЗначениеN."
    },
    "DecodeV": {
      "Arguments": "Выражение - выражение, значение которого поочередно сравнивается со значениями аргументов Значение.\nЗначение - выражение, величина которого сравнивается с аргументом Выражение.\nРезультат - выражение, которое возвращается, если Выражение = Значение.\nЗначение_по_умолчанию - выражение, результат которого возвращается, если Выражение не равно ни одному из Значений (если не указано, то равно Null).",
      "Description": "DecodeV(Выражение, Значение, Результат [, Значение, Результат]... [, Значение_по_умолчанию = Null])",
      "Output": " Реализует функциональность IF - THEN - ELSE.\n Все выражения Результат вычисляются до сравнения Выражения со Значениями"
    },
    "DisplayName": {
      "Arguments": "ИмяПоля - имя поля, переменной или выражения",
      "Description": "DisplayName([\"ИмяПоля\"])",
      "Output": "Функция возвращает метку (отображаемое имя) по имени поля, переменной или выражения.\nЕсли функция вызывается без аргументов, то она возвращает метку текущего вычисляемого выражения.\nПримечание: ИмяПоля - строковое значение, т.е. явно заданное ИмяПоля должно быть указано в кавычках.\nНапример: DisplayName(\"COL1\")"
    },
    "EncodeDate": {
      "Arguments": "Год - год в виде числа,\nМесяц - месяц в виде числа,\nДень - день в виде числа.",
      "Description": "EncodeDate(Год, Месяц, День)",
      "Output": "Функция возвращает дату, сформированную из указанных аргументов."
    },
    "EncodeDateTime": {
      "Arguments": "Год - год в виде числа,\nМесяц - месяц в виде числа,\nДень - день в виде числа,\nЧасы - часы в виде числа,\nМинуты - минуты в виде числа,\nСекунды - секунды в виде числа.",
      "Description": "EncodeDateTime(Год, Месяц, День, Часы, Минуты, Секунды)",
      "Output": "Функция возвращает дату и время, сформированные из указанных аргументов."
    },
    "EncodeTime": {
      "Arguments": "Часы - часы в виде числа,\nМинуты - минуты в виде числа,\nСекунды - секунды в виде числа.",
      "Description": "EncodeTime(Часы, Минуты, Секунды)",
      "Output": "Функция возвращает время, сформированное из указанных аргументов."
    },
    "Exp": {
      "Arguments": "Степень - числовое выражение.",
      "Description": "Exp(Степень)",
      "Output": "Возвращает число e в заданной степени."
    },
    "ExpMovingAverage": {
      "Arguments": "Аргументы - значения числового ряда",
      "Description": "ExpMovingAverage(X{t}, X{t-1} ...)",
      "Output": "Применяется для построения пользовательской модели экспоненциально сглаженного скользящего среднего.\n\nЭкспоненциально сглаженное скользящее среднее, в отличие от простого скользящего среднего придает последним наблюдениям более значимый вес, чем предпоследним, и т.д.\n\nФормула вычисления задается рекуррентным соотношением: EMA(t) = a * X(t) + (1 - a) * EMA(t-1), где EMA(k) - значение экспоненциально сглаженного скользящего среднего в точке k, a - параметр сглаживания, a = 2 / (n + 1), где n - ширина окна."
    },
    "Factorial": {
      "Arguments": "Аргумент - целое положительное числовое выражение.",
      "Description": "Factorial(Аргумент)",
      "Output": "Возвращает факториал аргумента."
    },
    "Find": {
      "Arguments": "Подстрока - искомая подстрока,\nСтрока - строка, в которой ищется подстрока,\nПорядок - необязательный параметр, позицию какого по счету вхождения Подстроки в Строку возвращать. Аргумент числового типа.",
      "Description": "Find(Подстрока, Строка[, Порядок = 1])",
      "Output": "Функция возвращает позицию первого символа Подстроки заданного Порядка в Строке.\n Порядок может быть как положительным, так и отрицательным. Если Порядок положительный, то поиск происходит слева направо, если отрицательный, то справа налево.\n Если вхождения заданного порядка нет, то функция возвращает 0.\n Например, Find(\"A\", \"A000A00A\", 2) вернет позицию второго слева вхождения подстроки \"A\" в строку \"A000A00A\", т.е. 5;\n Find(\"A\", \"A000A00A\", -1) вернет позицию первого справа вхождения подстроки \"A\" в строку \"A000A00A\", т.е. 8.\n Если Порядок равен нулю, то функция возвращает Неопределенное значение (Null)."
    },
    "Format": {
      "Arguments": "Строка_формата - строковое выражение специального вида\nВыражение - произвольное строковое выражение.",
      "Description": "Format(Строка_формата, Выражение [, ... Выражение])",
      "Output": "Возвращает список выражений в заданном формате.\nСтрока_формата имеет следующий вид:\n       [Строка] %s [Строка] [... [[Строка]%s[Строка]]]\n       Строка - строковое выражение\n       %s - символ, на место которого ставится очередное Выражение из списка."
    },
    "Frac": {
      "Arguments": "Аргумент - числовое выражение.",
      "Description": "Frac(Аргумент)",
      "Output": "Возвращает дробную часть Аргумента."
    },
    "Hour": {
      "Arguments": "ДатаВремя - поле типа дата/время.",
      "Description": "Hour(ДатаВремя)",
      "Output": "Возвращает час по заданной дате/времени."
    },
    "IF": {
      "Arguments": "Условие - логическое выражение;\nЗначение1,\nЗначение2 - выражения любых типов",
      "Description": "IF(Условие, Значение1, Значение2)",
      "Output": "Возвращает Значение1, если Условие истинно или Значение2, если ложно. Результат функции имеет переменный тип"
    },
    "IFF": {
      "Arguments": "Условие - логическое выражение;\nЗначение1,\nЗначение2 - числовые выражения или выражения типа Дата/время",
      "Description": "IFF(Условие, Значение1, Значение2)",
      "Output": "Возвращает Значение1, если Условие истинно или Значение2, если ложно."
    },
    "IN": {
      "Arguments": "Значение - значение искомого элемента;\nЭлемент1,\nЭлемент2,\nЭлементN - значения элементов списка",
      "Description": "IN(Значение, Элемент1, Элемент2, ..., ЭлементN)",
      "Output": "Функция возвращает значение логического типа TRUE (истина), если Значение содержится в списке, иначе результат равен FALSE (ложь)."
    },
    "Int": {
      "Arguments": "Аргумент - числовое выражение.",
      "Description": "Int(Аргумент)",
      "Output": "Возвращает целую часть Аргумента."
    },
    "IsInfinite": {
      "Arguments": "Аргумент - числовое выражение;",
      "Description": "IsInfinite(Аргумент)",
      "Output": "Определяет, является ли переданное значение бесконечным числом."
    },
    "IsNull": {
      "Arguments": "Аргумент - любое выражение;",
      "Description": "IsNull(Аргумент)",
      "Output": "Проверяет, является ли Аргумент пустым. Возвращает логическое значение."
    },
    "ISO8601ToDate": {
      "Arguments": "Аргумент - строковое выражение, содержащее дату/время в формате ISO 8601",
      "Description": "ISO8601ToDate(Аргумент)",
      "Output": "Функция конвертирует строку, содержащую дату/время в формате ISO 8601 в значение типа \"Дата/Время\".\nПри указанном смещении времени относительно UTC дата/время приводится к текущей временной зоне.\nЕсли смещение времени не указано, дата/время остаётся без изменений."
    },
    "Left": {
      "Arguments": "Строка - выражение строкового типа.",
      "Description": "Left(Строка, Количество_символов)",
      "Output": "Возвращает заданное количество символов левой части строки."
    },
    "LevDist": {
      "Arguments": "Строка1,\nСтрока2 - выражения строкового типа.",
      "Description": "LevDist(Строка1, Строка2)",
      "Output": "Функция возвращает значение расстояния Левенштейна для строк Строка1, Строка2. Расстояние Левенштейна также называют расстоянием редактирования, которое является мерой похожести двух строк. Результат - это минимальное количество операций удалений, вставки и замены символа, которое нужно произвести, чтобы преобразовать одну строку в другую."
    },
    "Ln": {
      "Arguments": "Аргумент - положительное числовое выражение.",
      "Description": "Ln(Аргумент)",
      "Output": "Возвращает натуральный логарифм аргумента."
    },
    "Log": {
      "Arguments": "Основание - числовое выражение;\nАргумент - положительное числовое выражение.",
      "Description": "Log(Основание, Аргумент)",
      "Output": "Возвращает логарифм аргумента с заданным основанием."
    },
    "Lower": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "Lower(Аргумент)",
      "Output": "Возвращает аргумент в нижнем регистре."
    },
    "Max": {
      "Arguments": "Аргумент1,\nАргумент2,\n... - числовые выражения.",
      "Description": "Max(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает максимальное из аргументов."
    },
    "Min": {
      "Arguments": "Аргумент1,\nАргумент2,\n... - числовые выражения.",
      "Description": "Min(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает минимальное из аргументов."
    },
    "Minute": {
      "Arguments": "ДатаВремя - поле типа дата/время.",
      "Description": "Minute(ДатаВремя)",
      "Output": "Возвращает минуты по заданной дате/времени."
    },
    "Mod": {
      "Arguments": "Делимое - целое числовое выражение,\nДелитель - целое числовое выражение.",
      "Description": "Mod(Делимое, Делитель)",
      "Output": "Возвращает остаток от целочисленного деления Делимого на Делитель."
    },
    "Month": {
      "Arguments": "Дата - поле типа дата.",
      "Description": "Month(Дата)",
      "Output": "Возвращает месяц по заданной дате."
    },
    "MonthsBetween": {
      "Arguments": "Дата1, Дата2 - поля типа дата.",
      "Description": "MonthsBetween(Дата1, Дата2)",
      "Output": "Возвращает полное количество месяцев между двумя датами."
    },
    "MovingAverage": {
      "Arguments": "Аргументы - значения числового ряда",
      "Description": "MovingAverage(X{t}, X{t-1} ...)",
      "Output": "Применяется для построения пользовательской модели простого скользящего среднего в пользовательских моделях.\n\nФормула вычисления скользящего среднего:\nMA = (X(t) + ... + X(t - n))/n. "
    },
    "Now": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Now()",
      "Output": "Возвращает текущую дату и время.\nТак как текущая дата и время - это время вычисления выражения, которое считается каждый раз при получении значения этого выражения, например, при просмотре результата в виде таблицы или при выполнении экспорта данных, то можно, при наличии параметра выражения \"Кэшировать рассчитанные значения выражения\" включить эту опцию."
    },
    "Null": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Null()",
      "Output": "Функция возвращает пустое значение."
    },
    "NVL": {
      "Arguments": "Выражение - любое строковое или числовое выражение.\nЗначение_по_умолчанию - необязательный параметр, строковое или числовое выражение, значение которого возвращается, если Выражение равно Null.",
      "Description": "NVL(Выражение [, Значение_по_умолчанию = \"\"])",
      "Output": "Возвращает значение Выражения, если оно не равно Null, и Значение_по_умолчанию в противном случае."
    },
    "Pi": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Pi()",
      "Output": "Возвращает значение константы \"ПИ\" 3.1415926535897932385."
    },
    "Pow": {
      "Arguments": "Аргумент - числовое выражение;\nСтепень - числовое выражение;",
      "Description": "Pow(Аргумент, Степень)",
      "Output": "Возвращает аргумент в заданной степени."
    },
    "Random": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Random()",
      "Output": "Возвращает псевдослучайное равномерно распределенное число, большее или равное 0 и меньше 1.\nТак как случайное число будет генерироваться каждый раз при получении значения выражения, например, при просмотре результата в виде таблицы или при выполнении экспорта данных, то в общем случае рекомендуется при наличии параметра выражения \"Кэшировать\" включить эту опцию."
    },
    "RelErr": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "RelErr(Аргумент1, Аргумент2)",
      "Output": "Возвращает относительную погрешность двух аргументов."
    },
    "Repeat": {
      "Arguments": "Строка - строковое выражение.\nКоличество_повторов - целое выражение",
      "Description": "Repeat(Строка, Количество_повторов)",
      "Output": "Возвращает строку - повторяющую заданную строку необходимое количество раз."
    },
    "Replace": {
      "Arguments": "Строка - строка, в которой необходимо сделать замену;\nСтарый_шаблон - заменяемая подстрока;\nНовый_шаблон - строка, на которую будет заменяться Старый шаблон;\nЗаменять_все - флаг замены всех вхождений Старого шаблона на Новый шаблон. Аргумент логического типа;\nИгнорировать_регистр - флаг чувствительности к регистру при замене. Аргумент логического типа.",
      "Description": "Replace(Строка, Старый_шаблон, Новый_шаблон [, Заменять_все, Игнорировать_регистр])",
      "Output": "Функция возвращает Строку, в которой вхождения Старого шаблона были заменены на Новый шаблон.\n Если флаг \"Заменять все\" имеет значение True (истина), то в возвращаемой строке будут заменены все вхождения Старого Шаблона на Новый шаблон.\n Если флаг \"Заменять все\" имеет значение False (ложь), то в возвращаемой строке будет заменено только первое по порядку вхождение.\n Если флаг \"Игнорировать регистр\" имеет значение True (истина), то поиск заменяемых фрагментов (Старый шаблон) будет регистронезависимым.\n Если флаг \"Игнорировать регистр\" имеет значение False (ложь), то поиск заменяемых фрагментов (Старый шаблон) будет регистрозависимым.\n Последние два параметра можно не указывать.\n Если не указан флаг \"Игнорировать регистр\", то поиск заменяемых фрагментов будет регистрозависимым .\n Если не указан флаг \"Заменять все\", то будет заменено только первое вхождение заменяемой подстроки.\n Например, Replace(\"A000a00A\", \"A\", \"B\", True, True) вернет строку \"B000B00B\" , т.е. заменит все вхождения строки \"A\" на строку \"B\" игнорируя регистр символов;\n Replace(\"A000a00A\", \"A\", \"B\", True, False) вернет строку \"B000a00B\".\n Replace(\"A000a00A\", \"A\", \"B\") вернет строку \"B000a00A\"."
    },
    "Right": {
      "Arguments": "Строка - выражение строкового типа.",
      "Description": "Right(Строка, Количество_символов)",
      "Output": "Возвращает заданное количество символов правой части строки."
    },
    "Round": {
      "Arguments": "Аргумент1 - числовое выражение,\nАргумент2 - необязательный параметр, количество цифр после запятой, целое число.",
      "Description": "Round(Аргумент1 [, Аргумент2 = 0])",
      "Output": "Округляет вещественное число до ближайшего числа, имеющего указанное количество цифр после запятой."
    },
    "RowCount": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "RowCount()",
      "Output": "Функция возвращает число строк в источнике данных."
    },
    "RowNum": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "RowNum()",
      "Output": "Функция возвращает номер текущей строки источника данных. Нумерация строк начинается с 0."
    },
    "Second": {
      "Arguments": "ДатаВремя - поле типа дата/время.",
      "Description": "Second(ДатаВремя)",
      "Output": "Возвращает секунды по заданной дате/времени."
    },
    "Sign": {
      "Arguments": "Аргумент - числовое выражение;",
      "Description": "Sign(Аргумент)",
      "Output": "Возвращает знак аргумента."
    },
    "Sin": {
      "Arguments": "Угол - значение угла в радианах.",
      "Description": "Sin(Угол)",
      "Output": "Возвращает синус заданного угла."
    },
    "Space": {
      "Arguments": "Количество_пробелов - целое выражение.",
      "Description": "Space(Количество_пробелов)",
      "Output": "Возвращает заданное количество пробелов."
    },
    "Sqrt": {
      "Arguments": "Аргумент - положительное числовое выражение.",
      "Description": "Sqrt(Аргумент)",
      "Output": "Возвращает квадратный корень аргумента."
    },
    "StartOfTheWeek": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "StartOfTheWeek(Дата)",
      "Output": "Функция возвращает дату начала указанной недели в соответствии со стандартом ISO 8601, по которому неделя начинается с понедельника и заканчивается воскресеньем."
    },
    "Stat": {
      "Arguments": "ИмяПоля - поле, по которому необходимо получить значение показателя\nТип - показатель статистики, который необходимо получить",
      "Description": "Stat(\"ИмяПоля\", \"Тип\")",
      "Output": "Функция возвращает значение одного из статистических показателей.\nТип может принимать одно из следующих значений:\n       Min - минимальное значение\n       Max - максимальное значение\n       Avg - среднее значение\n       StdDev - стандартное отклонение\n       Sum - сумма значений\n       SumSq - сумма квадратов значений\n       Count - количество значений\n       UniqueCount - количество уникальных значений\n       NullCount - количество пропущенных значений\n       Mode - мода (значение, которое встречается наиболее часто)\nПримечание: ИмяПоля и Тип - строковые значения, т.е. явно заданные ИмяПоля и Тип должны быть указаны в кавычках.\nНапример: Stat(\"COL1\", \"Min\")"
    },
    "StdDev": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "StdDev(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает стандартное отклонение аргументов."
    },
    "Str": {
      "Arguments": "Аргумент - выражение числового типа.",
      "Description": "Str(Аргумент)",
      "Output": "Возвращает строковое представление Аргумента с учетом локали."
    },
    "StrToDate": {
      "Arguments": "Аргумент - строковое выражение, содержащее дату/время\nФормат - необязательный параметр формат даты/время в терминах D, M, Y, H, N, S, Z",
      "Description": "StrToDate(Аргумент [, Формат])",
      "Output": "Функция конвертирует строку, содержащую дату в формат типа \"Дата/Время\".\nПримеры формата:\n  \"DD.MM.YY\" - определяет, что Аргумент содержит строки вида \"25.12.04\";\n  \"DD/MM/YY HH:NN:SS\" - определяет, что Аргумент содержит строки вида \"25/12/04 12:44:54\";"
    },
    "StrZero": {
      "Arguments": "Выражение - числовое выражение.\nОбщая_длина - длина результирующей строки",
      "Description": "StrZero(Выражение, Общая_длина)",
      "Output": "Добавляет спереди заданного выражения нули так, чтобы длина результирующей строки равнялась Общей_длине."
    },
    "Stuff": {
      "Arguments": "Источник - строковое выражение.\nВставляемая_строка - строковое выражение.\nНачало - позиция начала вставки\nДлина - длина удаляемой подстроки",
      "Description": "Stuff(Источник, Начало, Длина [, Вставляемая_строка = \"\"])",
      "Output": "Возвращает строку следующего вида. Сначала из Источника удаляется подстрока, начиная с позиции Начало длиной Длина. Затем на место удаленной подстроки вставляется Вставляемая_строка."
    },
    "SubStr": {
      "Arguments": "Источник - строковое выражение.\nНачало - позиция начало подстроки\nДлина - длина подстроки",
      "Description": "SubStr(Источник, Начало, Длина)",
      "Output": "Возвращает подстроку из строки - источника, начиная с позиции Начало длиной Длина."
    },
    "Sum": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "Sum(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает сумму аргументов."
    },
    "SumSq": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "SumSq(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает сумму квадратов аргументов."
    },
    "Tan": {
      "Arguments": "Угол - значение угла в радианах.",
      "Description": "Tan(Угол)",
      "Output": "Возвращает тангенс заданного угла."
    },
    "Today": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Today()",
      "Output": "Возвращает текущую дату.\nТак как текущая дата - это дата вычисления выражения, которое считается каждый раз при получении значения этого выражения, например, при просмотре результата в виде таблицы или при выполнении экспорта данных, то можно, при наличии параметра выражения \"Кэшировать рассчитанные значения выражения\" включить эту опцию."
    },
    "Trim": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "Trim(Аргумент)",
      "Output": "Возвращает Аргумент без ведущих и ведомых пробелов."
    },
    "TrimLeft": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "TrimLeft(Аргумент)",
      "Output": "Возвращает Аргумент без ведущих пробелов."
    },
    "TrimRight": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "TrimRight(Аргумент)",
      "Output": "Возвращает Аргумент без ведомых пробелов."
    },
    "Upper": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "Upper(Аргумент)",
      "Output": "Возвращает аргумент в верхнем регистре."
    },
    "Val": {
      "Arguments": "Строка - строковое выражение.",
      "Description": "Val(Строка)",
      "Output": "Преобразует заданную строку в число с учетом локали"
    },
    "Week": {
      "Arguments": "Дата - поле типа дата.",
      "Description": "Week(Дата)",
      "Output": "Возвращает номер недели в году по заданной дате в соответствии со стандартом ISO 8601, по которому неделя начинается с понедельника и заканчивается воскресеньем. Первая неделя года начинается с понедельника, для дней с 1 января по первый понедельник возвращается номер последней недели предыдущего года."
    },
    "Year": {
      "Arguments": "Дата - поле типа дата.",
      "Description": "Year(Дата)",
      "Output": "Возвращает год по заданной дате."
    },
    "YearsBetween": {
      "Arguments": "Дата1, Дата2 - поля типа дата.",
      "Description": "YearsBetween(Дата1, Дата2)",
      "Output": "Возвращает полное количество лет между двумя датами."
    }
  },
  "RegExFunctions": {
    "RegExDomain": {
      "Arguments": "Вх.Строка - входная строка, в которой будет искаться домен;\nНом.Вхожд - порядковый номер домена, в искомой строке.",
      "Description": "RegExDomain(Вх.Строка [, Ном.Вхожд = 1])",
      "Output": "Возвращает Ном.Вхожд-й доменного имени из строки Вх.Строка не включая www до домена 1-го уровня включительно.\nДля поиска используются регулярные выражения."
    },
    "RegExEmail": {
      "Arguments": "Вх.Строка - входная строка, в которой будет искаться Email-адрес;\nНом.Вхожд - порядковый номер Email-адрес-а, в искомой строке.",
      "Description": "RegExEmail(Вх.Строка [, Ном.Вхожд = 1])",
      "Output": "Извлекает Ном.Вхожд-й Email-адрес из строки Вх.Строка.\nДля поиска используются регулярные выражения."
    },
    "RegExMatch": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка.",
      "Description": "RegExMatch(Рег.Выр., Строка)",
      "Output": "Проверяет соответствие строки регулярному выражению.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExMatchCount": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка.",
      "Description": "RegExMatchCount(Рег.Выр., Строка)",
      "Output": "Возвращает кол-во частей строки, соответствующих регулярному выражению.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExMatchedExp": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка;\nНомерЧасти - порядковый номер части, соответствующей регулярному выражению, входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.",
      "Description": "RegExMatchedExp(Рег.Выр., Строка [, НомерЧасти = 1])",
      "Output": "Возвращает часть строки, соответствующую регулярному выражению.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExMatchedNamedSubExp": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка;\nИмяГруппы - имя группы, определяемой метасимволами (...);\nНомерЧасти - порядковый номер части, соответствующей регулярному выражению, входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.",
      "Description": "RegExMatchedNamedSubExp(Рег.Выр., Строка, ИмяГруппы [, НомерЧасти = 1])",
      "Output": "Возвращает именованную группу части строки, соответствующую регулярному выражению.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExMatchedSubExp": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка;\nНомерГруппы - порядковый номер группы, определяемой метасимволами (...);\nНомерЧасти - порядковый номер части, соответствующей регулярному выражению, входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.",
      "Description": "RegExMatchedSubExp(Рег.Выр., Строка, НомерГруппы [, НомерЧасти = 1])",
      "Output": "Возвращает группу части строки, соответствующую регулярному выражению.\nГруппы нумеруются слева направо, в порядке появления открывающихся скобок.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExReplace": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nВх.Строка - входная строка, которая будет подвержена замене;\nСтрокаЗамены - строка, которая будет вставлена вместо части входной строки, соответствующией регулярному выражению;\nНомерЧасти - порядковый номер части, соответствующей регулярному выражению, входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.\nРасш.Синтаксис - расширенный синтаксис замены (используется библиотека PCRE2)",
      "Description": "RegExReplace(Рег.Выр., Вх.Строка, СтрокаЗамены [, НомерЧасти = 1, Расш.Синтаксис = False])",
      "Output": "Возвращает Вх.Строка, в которой НомерЧасти-ое вхождение выражения Рег.Выр. будет заменено на СтрокаЗамены.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExReplaceAll": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nВх.Строка - входная строка, которая будет подвержена замене;\nСтрокаЗамены - строка, которая будет вставлена вместо частей входной строки, соответствующих регулярному выражению.\nРасш.Синтаксис - расширенный синтаксис замены (используется библиотека PCRE2)",
      "Description": "RegExReplaceAll(Рег.Выр., Вх.Строка, СтрокаЗамены [, Расш.Синтаксис = False])",
      "Output": "Возвращает Вх.Строка, в которой все вхождения выражения Рег.Выр. будут заменены на СтрокаЗамены.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    }
  },
  "StatFunctions": {
    "DKhi2": {
      "Arguments": "Степени_свободы - число степеней свободы.\nАргумент - значение, для которого требуется вычислить плотность распределения.",
      "Description": "DKhi2(Степени_свободы, Аргумент)",
      "Output": "Функция плотности гамма-распределения хи-квадрат."
    },
    "FKhi2": {
      "Arguments": "Степени_свободы - число степеней свободы.\nАргумент - значение, для которого требуется вычислить плотность распределения.",
      "Description": "FKhi2(Степени_свободы, Аргумент)",
      "Output": "Интегральная функция гамма-распределения, равная (1 - односторонняя вероятность распределения хи-квадрат) с n степенями свободы."
    },
    "InvKhi2": {
      "Arguments": "Степени_свободы - число степеней свободы.\nВероятность - вероятность, связанная с гамма-распределением.",
      "Description": "InvKhi2(Степени_свободы, Вероятность)",
      "Output": "Возвращает обратное гамма-распределение для интегральной функции, равной (1 - односторонняя вероятность распределения хи-квадрат). Если p=FKhi2(N, X), то InvKhi2(N, P) = X"
    },
    "PKhi2": {
      "Arguments": "Степени_свободы - число степеней свободы.\nАргумент - значение, для которого требуется вычислить плотность распределения.",
      "Description": "PKhi2(Степени_свободы, Аргумент)",
      "Output": "Возвращает одностороннюю вероятность распределения хи-квадрат."
    }
  }
}