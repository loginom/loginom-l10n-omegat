{
  "CryptFunctions": {
    "CRC32": {
      "Arguments": "Строка - строка, для которой рассчитывается CRC32 значение.",
      "Description": "CRC32(Строка)",
      "Output": "Функция возвращает число - значение CRC32, рассчитанное от заданной строки.\nРасчеты производятся над последовательностью символов Строки в кодировке UTF-8."
    },
    "HardKey": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "HardKey()",
      "Output": "Функция возвращает серийный номер электронного ключа."
    },
    "MD5": {
      "Arguments": "Строка - строка, для которой рассчитывается MD5 значение.",
      "Description": "MD5(Строка)",
      "Output": "Функция возвращает HEX значение MD5, рассчитанное от заданной строки.\nРасчеты производятся над последовательностью символов Строки в кодировке UTF-8."
    },
    "SHA1": {
      "Arguments": "Строка - строка, для которой рассчитывается SHA1 значение.",
      "Description": "SHA1(Строка)",
      "Output": "Функция возвращает HEX значение SHA1, рассчитанное от заданной строки.\nРасчеты производятся над последовательностью символов Строки в кодировке UTF-8."
    }
  },
  "DataFunctions": {
    "CumulativeSum": {
      "Arguments": "ИмяПоля - поле, по которому необходимо получить накапливающуюся сумму\nИмяПоляГруппы - поле, по которому происходит группировка данных. Этот параметр не является обязательным. Если этот параметр указан, то накапливающиеся суммы считаются в пределах групп.",
      "Description": "CumulativeSum(\"ИмяПоля\" [, \"ИмяПоляГруппы\"])",
      "Output": "Функция возвращает накапливающуюся сумму по полю.\nПримечание: ИмяПоля и ИмяПоляГруппы - строковые значения, т.е. явно заданные ИмяПоля и ИмяПоляГруппы должны быть указаны в кавычках.\nНапример: CumulativeSum(\"COL1\", \"COL2\")"
    },
    "Data": {
      "Arguments": "ИмяПоля - имя поля, данные которого необходимо получить\nНомерСтроки - номер строки, значение которой необходимо получить. Нумерация строк начинается с 0.",
      "Description": "Data(\"ИмяПоля\",НомерСтроки)",
      "Output": "Функция возвращает значение поля ИмяПоля взятое из строки НомерСтроки.\nПри рекурсивном использовании данной функции необходимо в окне \"Параметры выражения\" установить флаг \"Кэшировать\".\nПримечание: ИмяПоля - строковое значение, т.е. явно заданное ИмяПоля должно быть указано в кавычках.\nНапример: Data(\"COL1\", 2)"
    },
    "DisplayName": {
      "Arguments": "ИмяПоля - имя поля, переменной или выражения",
      "Description": "DisplayName([\"ИмяПоля\"])",
      "Output": "Функция возвращает метку (отображаемое имя) по имени поля, переменной или выражения.\nЕсли функция вызывается без аргументов, то она возвращает метку текущего вычисляемого выражения.\nПримечание: ИмяПоля - строковое значение, т.е. явно заданное ИмяПоля должно быть указано в кавычках.\nНапример: DisplayName(\"COL1\")"
    },
    "RowCount": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "RowCount()",
      "Output": "Функция возвращает число строк в источнике данных."
    },
    "RowNum": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "RowNum()",
      "Output": "Функция возвращает номер текущей строки источника данных. Нумерация строк начинается с 0."
    },
    "Stat": {
      "Arguments": "ИмяПоля - поле, по которому необходимо получить значение показателя\nТип - показатель статистики, который необходимо получить",
      "Description": "Stat(\"ИмяПоля\", \"Тип\")",
      "Output": "Функция возвращает значение одного из статистических показателей.\nТип может принимать одно из следующих значений:\n       Min - минимальное значение\n       Max - максимальное значение\n       Avg - среднее значение\n       StdDev - стандартное отклонение\n       Sum - сумма значений\n       SumSq - сумма квадратов значений\n       Count - количество значений\n       UniqueCount - количество уникальных значений\n       NullCount - количество пропущенных значений\n       Mode - мода (значение, которое встречается наиболее часто)\nПримечание: ИмяПоля и Тип - строковые значения, т.е. явно заданные ИмяПоля и Тип должны быть указаны в кавычках.\nНапример: Stat(\"COL1\", \"Min\")"
    }
  },
  "Functions": {
    "Abs": {
      "Arguments": "Аргумент - числовое выражение.",
      "Description": "Abs(Аргумент)",
      "Output": "Возвращает модуль аргумента."
    },
    "AbsErr": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "AbsErr(Аргумент1, Аргумент2)",
      "Output": "Возвращает абсолютную погрешность двух аргументов."
    },
    "AddDay": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddDay(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество дней. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество дней раньше указанной даты."
    },
    "AddHour": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddHour(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество часов. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество часов раньше указанной даты."
    },
    "AddMillisecond": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddMillisecond(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество миллисекунд. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество миллисекунд раньше указанной даты."
    },
    "AddMinute": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddMinute(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество минут. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество минут раньше указанной даты."
    },
    "AddMonth": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddMonth(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество месяцев. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество месяцев раньше указанной даты.\n\nЕсли указанный день месяца больше, чем последний день получившегося месяца, то функция устанавливает дату на последний день получившегося месяца."
    },
    "AddQuarter": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddQuarter(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество кварталов. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество кварталов раньше указанной даты.\n\nЕсли указанный день месяца больше, чем последний день месяца получившегося квартала , то функция устанавливает дату на последний день месяца получившегося квартала."
    },
    "AddSecond": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddSecond(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество секунд. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество секунд раньше указанной даты."
    },
    "AddWeek": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddWeek(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество недель. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество недель раньше указанной даты."
    },
    "AddYear": {
      "Arguments": "Дата - аргумент типа Дата/Время\nКоличество - аргумент целого типа.",
      "Description": "AddYear(Дата, Количество)",
      "Output": "Функция возвращает значение аргумента Дата, увеличенного на указанное Количество лет. Количество может быть и отрицательным, тогда функция возвратит дату на указанное количество лет раньше указанной даты."
    },
    "AMGD": {
      "Arguments": "Аргументы - числовые выражения.",
      "Description": "AMGD(Стоимость, Остаточная_стоимость, Время_эксплуатации, Период)",
      "Output": "Возвращает годовую амортизацию имущества для указанного периода."
    },
    "ArcCos": {
      "Arguments": "Значение - значение косинуса, для которого необходимо найти угол.",
      "Description": "ArcCos(Значение)",
      "Output": "Возвращает арккосинус значения, т.е. угол в радианах, косинус которого равен Значение."
    },
    "ArcSin": {
      "Arguments": "Значение - значение синуса, для которого необходимо найти угол.",
      "Description": "ArcSin(Значение)",
      "Output": "Возвращает арксинус значения, т.е. угол в радианах, синус которого равен Значение."
    },
    "ArcTan": {
      "Arguments": "Значение - значение тангенса, для которого необходимо найти угол.",
      "Description": "ArcTan(Значение)",
      "Output": "Возвращает арктангенс значения, т.е. угол в радианах, тангенс которого равен Значение."
    },
    "AutoRegression": {
      "Arguments": "C - постоянная,\nA0 ... An - коэффициенты регрессии,\nX(t) ... X(t-n) - значения ряда.",
      "Description": "AutoRegression(C, A0, X{t}, A1, X{t-1} ...)",
      "Output": "Применяется для построения пользовательской модели авторегрессии вида\nПрогноз = С + A0 * X(t) + A1 * X(t-1) + ..."
    },
    "Avg": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "Avg(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает среднее арифметическое аргументов."
    },
    "Chr": {
      "Arguments": "Аргумент - числовой код символа Unicode.",
      "Description": "Chr(Аргумент)",
      "Output": "Возвращает символ Unicode по его коду."
    },
    "Concat": {
      "Arguments": "Строка - строковое выражение.",
      "Description": "Concat(Строка, Строка [, ... Строка])",
      "Output": "Объединяет несколько строк в одну.\nПропущенные значения интерпретируются как строки с нулевой длиной, т.е. как \"\"."
    },
    "Cos": {
      "Arguments": "Угол - значение угла в радианах.",
      "Description": "Cos(Угол)",
      "Output": "Возвращает косинус заданного угла."
    },
    "Count": {
      "Arguments": "Строка - строковое выражение.",
      "Description": "Count(Строка)",
      "Output": "Возвращает количество символов в строке."
    },
    "CreateGUID": {
      "Arguments": "Формат - способ строкового представления GUID (\"N\", \"D\", \"B\", \"P\").\nВерхнийРегистр - аргумент логического типа, определяющий регистр символов шестнадцатеричных цифр.",
      "Description": "CreateGUID([Формат = \"B\", ВерхнийРегистр = True])",
      "Output": "Функция возвращает строковое представление GUID в указанном формате:\n  \"N\" - 32 цифры;\n  \"D\" - 32 цифры, разделенные дефисами;\n  \"B\" - 32 цифры, разделенные дефисами и заключенные в фигурные скобки;\n  \"P\" - 32 цифры, разделенные дефисами и заключенные в круглые скобки.\nЕсли формат не указан, то используется формат \"B\". По умолчанию шестнадцатеричные цифры записываются в верхнем регистре.\nТак как GUID будет генерироваться каждый раз при получении значения выражения, например, при просмотре результата в виде таблицы или при выполнении экспорта данных, то в общем случае рекомендуется при наличии параметра выражения \"Кэшировать\" включить эту опцию."
    },
    "DamLevDist": {
      "Arguments": "Строка1,\nСтрока2 - выражения строкового типа.",
      "Description": "DamLevDist(Строка1, Строка2)",
      "Output": "Функция возвращает значение расстояния Дамерау-Левенштейна для строк Строка1, Строка2. Расстояние Дамерау-Левенштейна также называют расстоянием редактирования с учётом перестановок, которое является мерой похожести двух строк. Результат - это минимальное количество операций удалений, вставки, замены и перестановок символов, которое нужно произвести, чтобы преобразовать одну строку в другую."
    },
    "DateTimeToStr": {
      "Arguments": "Дата_время - выражение типа Дата/Время.\nФормат_даты - необязательный параметр формат даты в терминах D, M, Y.\nФормат_времени - необязательный параметр формат времени в терминах H, N, S, Z.",
      "Description": "DateTimeToStr(Дата_время [, Формат_даты [, Формат_времени]])",
      "Output": "Возвращает строковое представление аргумента Дата_время.\nПримеры формата даты:\n  \"DD.MM.YY\" - преобразует дату в формат \"день.месяц.год\" (\"25.12.04\")\n  \"MM/DD/YYYY\" - преобразует дату в формат \"месяц.день.год\" (\"12/25/2004\")\nПримеры формата времени:\n  \"H:NN\" - преобразует время в формат \"часы:минуты\" (\"9:53\")\n  \"HH:NN:SS\" - преобразует время в формат \"часы:минуты:секунды\" (\"09:05:53\")"
    },
    "DateToStr": {
      "Arguments": "Дата - выражение типа Дата/Время.\nФормат - необязательный параметр формат даты в терминах D, M, Y.",
      "Description": "DateToStr(Дата [, Формат])",
      "Output": "Возвращает строковое представление аргумента Дата.\nПримеры формата даты:\n  \"DD.MM.YY\" - преобразует дату в формат \"день.месяц.год\" (\"25.12.04\")\n  \"MM/DD/YYYY\" - преобразует дату в формат \"месяц.день.год\" (\"12/25/2004\")"
    },
    "Day": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "Day(Дата)",
      "Output": "Возвращает день по заданной дате."
    },
    "DayOfWeek": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "DayOfWeek(Дата)",
      "Output": "Возвращает день недели заданной даты."
    },
    "DaysBetween": {
      "Arguments": "Дата1, Дата2 - аргументы типа Дата/Время.\nАбсолютное_Значение - необязательный параметр логического типа.",
      "Description": "DaysBetween(Дата1, Дата2[, Абсолютное_Значение = True])",
      "Output": "Возвращает количество полных дней между двумя датами.\nЕсли Дата2 раньше Дата1 и Абсолютное_Значение = False, то будет возвращено отрицательное число полных временных промежутков между датами; если Абсолютное_значение = True, то функция вернёт модуль значения"
    },
    "Decode": {
      "Arguments": "Выражение - выражение, значение которого поочередно сравнивается со значениями аргументов ЗначениеN.\nЗначениеN - выражение, величина которого сравнивается с аргументом Выражение.\nРезультатN - выражение строкового типа, которое возвращается, если Выражение = ЗначениеN.\nЗначение_по_умолчанию - выражение строкового типа, результат которого возвращается, если Выражение не равно ни одному из ЗначениеN (если не указано, то равно \"\").",
      "Description": "Decode(Выражение, Значение1, Результат1 [, Значение2, Результат2]... [, Значение_по_умолчанию = \"\"])",
      "Output": " Реализует функциональность IF - THEN - ELSE, при этом результат функции имеет строковый тип.\n Все выражения РезультатN вычисляются до сравнения Выражения с ЗначениеN."
    },
    "DecodeF": {
      "Arguments": "Выражение - любое числовое выражение, величина которого используется для сравнения.\nПогрешность - числовое выражение, погрешность сравнения.\nЗначениеN - числовое выражение, величина которого сравнивается с аргументом Выражение.\nРезультатN - значение, которое возвращается, если |ЗначениеN - ВыражениеN| <= Погрешность.\nЗначение_по_умолчанию - числовое выражение, результат которого возвращается, если ни одно ЗначениеN не равно Выражению (по умолчанию 0).",
      "Description": "DecodeF(Выражение, Погрешность, Значение1, Результат1 [, Значение2, Результат2]... [, Значение_по_умолчанию = 0])",
      "Output": " Реализует функциональность IF - THEN - ELSE, при этом результат функции, также как и все ее аргументы, имеют числовой тип или тип Дата/Время.\n Все выражения РезультатN вычисляются до сравнения Выражения с ЗначениеN."
    },
    "DecodeN": {
      "Arguments": "Выражение - выражение, значение которого поочередно сравнивается со значениями аргументов ЗначениеN.\nЗначениеN - выражение, величина которого сравнивается с аргументом Выражение.\nРезультатN - выражение числового типа или типа Дата/Время, которое возвращается, если Выражение = ЗначениеN.\nЗначение_по_умолчанию - выражение числового типа или типа Дата/Время, результат которого возвращается, если Выражение не равно ни одному из ЗначениеN (если не указано, то равно 0).",
      "Description": "DecodeN(Выражение, Значение1, Результат1 [, Значение2, Результат2]... [, Значение_по_умолчанию = 0])",
      "Output": " Реализует функциональность IF - THEN - ELSE, при этом результат функции имеет числовой тип или тип Дата/Время.\n Все выражения РезультатN вычисляются до сравнения Выражения с ЗначениеN."
    },
    "DecodeS": {
      "Arguments": "Выражение - выражение, значение которого поочередно сравнивается со значениями аргументов ЗначениеN.\nЗначениеN - выражение, величина которого сравнивается с аргументом Выражение.\nРезультатN - выражение строкового типа, которое возвращается, если Выражение = ЗначениеN.\nЗначение_по_умолчанию - выражение строкового типа, результат которого возвращается, если Выражение не равно ни одному из ЗначениеN (если не указано, то равно \"\").",
      "Description": "DecodeS(Выражение, Значение1, Результат1 [, Значение2, Результат2]... [, Значение_по_умолчанию = \"\"])",
      "Output": " Реализует функциональность IF - THEN - ELSE, при этом результат функции имеет строковый тип.\n Все выражения РезультатN вычисляются до сравнения Выражения с ЗначениеN."
    },
    "DecodeV": {
      "Arguments": "Выражение - выражение, значение которого поочередно сравнивается со значениями аргументов Значение.\nЗначение - выражение, величина которого сравнивается с аргументом Выражение.\nРезультат - выражение, которое возвращается, если Выражение = Значение.\nЗначение_по_умолчанию - выражение, результат которого возвращается, если Выражение не равно ни одному из Значений (если не указано, то равно Null).",
      "Description": "DecodeV(Выражение, Значение, Результат [, Значение, Результат]... [, Значение_по_умолчанию = Null])",
      "Output": " Реализует функциональность IF - THEN - ELSE.\n Все выражения Результат вычисляются до сравнения Выражения со Значениями"
    },
    "Div": {
      "Arguments": "Делимое - целое числовое выражение,\nДелитель - целое числовое выражение.",
      "Description": "Div(Делимое, Делитель)",
      "Output": "Возвращает частное целочисленного деления Делимого на Делитель."
    },
    "EncodeDate": {
      "Arguments": "Год - год в виде числа,\nМесяц - месяц в виде числа,\nДень - день в виде числа.",
      "Description": "EncodeDate(Год, Месяц, День)",
      "Output": "Функция возвращает дату, сформированную из указанных аргументов."
    },
    "EncodeDateTime": {
      "Arguments": "Год - год в виде числа,\nМесяц - месяц в виде числа,\nДень - день в виде числа,\nЧасы - часы в виде числа,\nМинуты - минуты в виде числа,\nСекунды - секунды в виде числа.",
      "Description": "EncodeDateTime(Год, Месяц, День, Часы, Минуты, Секунды)",
      "Output": "Функция возвращает дату и время, сформированные из указанных аргументов."
    },
    "EncodeTime": {
      "Arguments": "Часы - часы в виде числа,\nМинуты - минуты в виде числа,\nСекунды - секунды в виде числа.",
      "Description": "EncodeTime(Часы, Минуты, Секунды)",
      "Output": "Функция возвращает время, сформированное из указанных аргументов."
    },
    "EndOfTheMonth": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "EndOfTheMonth(Дата)",
      "Output": "Функция возвращает дату и время окончания месяца, указанного в Дата"
    },
    "EndOfTheQuarter": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "EndOfTheQuarter(Дата)",
      "Output": "Функция возвращает дату и время окончания квартала, к которому относится указанная Дата"
    },
    "EndOfTheWeek": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "EndOfTheWeek(Дата)",
      "Output": "Функция возвращает дату и время окончания указанной недели в соответствии со стандартом ISO 8601, по которому неделя начинается с понедельника и заканчивается воскресеньем."
    },
    "EndOfTheYear": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "EndOfTheYear(Дата)",
      "Output": "Функция возвращает дату и время окончания года, указанного в Дата"
    },
    "Exp": {
      "Arguments": "Степень - числовое выражение.",
      "Description": "Exp(Степень)",
      "Output": "Возвращает число e в заданной степени."
    },
    "ExpMovingAverage": {
      "Arguments": "Аргументы - значения числового ряда",
      "Description": "ExpMovingAverage(X{t}, X{t-1} ...)",
      "Output": "Применяется для построения пользовательской модели экспоненциально сглаженного скользящего среднего.\n\nЭкспоненциально сглаженное скользящее среднее, в отличие от простого скользящего среднего придает последним наблюдениям более значимый вес, чем предпоследним, и т.д.\n\nФормула вычисления задается рекуррентным соотношением: EMA(t) = a * X(t) + (1 - a) * EMA(t-1), где EMA(k) - значение экспоненциально сглаженного скользящего среднего в точке k, a - параметр сглаживания, a = 2 / (n + 1), где n - ширина окна."
    },
    "Factorial": {
      "Arguments": "Аргумент - целое положительное числовое выражение.",
      "Description": "Factorial(Аргумент)",
      "Output": "Возвращает факториал аргумента."
    },
    "Find": {
      "Arguments": "Подстрока - искомая подстрока,\nСтрока - строка, в которой ищется подстрока,\nПорядок - необязательный параметр, позицию какого по счету вхождения Подстроки в Строку возвращать. Аргумент числового типа.",
      "Description": "Find(Подстрока, Строка[, Порядок = 1])",
      "Output": "Функция возвращает позицию первого символа Подстроки заданного Порядка в Строке.\n Порядок может быть как положительным, так и отрицательным. Если Порядок положительный, то поиск происходит слева направо, если отрицательный, то справа налево.\n Если вхождения заданного порядка нет, то функция возвращает 0.\n Например, Find(\"A\", \"A000A00A\", 2) вернет позицию второго слева вхождения подстроки \"A\" в строку \"A000A00A\", т.е. 5;\n Find(\"A\", \"A000A00A\", -1) вернет позицию первого справа вхождения подстроки \"A\" в строку \"A000A00A\", т.е. 8.\n Если Порядок равен нулю, то функция возвращает Неопределенное значение (Null)."
    },
    "Format": {
      "Arguments": "Строка_формата - строковое выражение специального вида\nВыражение - произвольное строковое выражение.",
      "Description": "Format(Строка_формата, Выражение [, ... Выражение])",
      "Output": "Возвращает список выражений в заданном формате.\nСтрока_формата имеет следующий вид:\n       [Строка] %s [Строка] [... [[Строка]%s[Строка]]]\n       Строка - строковое выражение\n       %s - символ, на место которого ставится очередное Выражение из списка."
    },
    "Frac": {
      "Arguments": "Аргумент - числовое выражение.",
      "Description": "Frac(Аргумент)",
      "Output": "Возвращает дробную часть Аргумента."
    },
    "Hour": {
      "Arguments": "ДатаВремя - аргумент типа Дата/Время.",
      "Description": "Hour(ДатаВремя)",
      "Output": "Возвращает час по заданной дате/времени."
    },
    "HoursBetween": {
      "Arguments": "Дата1, Дата2 - аргументы типа Дата/Время.\nАбсолютное_Значение - необязательный параметр логического типа.",
      "Description": "HoursBetween(Дата1, Дата2[, Абсолютное_Значение = True])",
      "Output": "Возвращает количество полных часов между двумя датами.\nЕсли Дата2 раньше Дата1 и Абсолютное_Значение = False, то будет возвращено отрицательное число полных временных промежутков между датами; если Абсолютное_значение = True, то функция вернёт модуль значения"
    },
    "IF": {
      "Arguments": "Условие - логическое выражение;\nЗначение1,\nЗначение2 - выражения любых типов",
      "Description": "IF(Условие, Значение1, Значение2)",
      "Output": "Возвращает Значение1, если Условие истинно или Значение2, если ложно. Результат функции имеет переменный тип"
    },
    "IFF": {
      "Arguments": "Условие - логическое выражение;\nЗначение1,\nЗначение2 - числовые выражения или выражения типа Дата/время",
      "Description": "IFF(Условие, Значение1, Значение2)",
      "Output": "Возвращает Значение1, если Условие истинно или Значение2, если ложно."
    },
    "IN": {
      "Arguments": "Значение - значение искомого элемента;\nЭлемент1,\nЭлемент2,\nЭлементN - значения элементов списка",
      "Description": "IN(Значение, Элемент1, Элемент2, ..., ЭлементN)",
      "Output": "Функция возвращает значение логического типа True (истина), если Значение содержится в списке, иначе результат равен False (ложь)."
    },
    "Int": {
      "Arguments": "Аргумент - числовое выражение.",
      "Description": "Int(Аргумент)",
      "Output": "Возвращает целую часть Аргумента."
    },
    "IsInfinite": {
      "Arguments": "Аргумент - числовое выражение;",
      "Description": "IsInfinite(Аргумент)",
      "Output": "Определяет, является ли переданное значение бесконечным числом."
    },
    "IsNull": {
      "Arguments": "Аргумент - любое выражение;",
      "Description": "IsNull(Аргумент)",
      "Output": "Проверяет, является ли Аргумент пустым. Возвращает логическое значение."
    },
    "ISO8601ToDate": {
      "Arguments": "Аргумент - строковое выражение, содержащее дату/время в формате ISO 8601",
      "Description": "ISO8601ToDate(Аргумент)",
      "Output": "Функция конвертирует строку, содержащую дату/время в формате ISO 8601 в значение типа \"Дата/Время\".\nПри указанном смещении времени относительно UTC дата/время приводится к текущей временной зоне.\nЕсли смещение времени не указано, дата/время остаётся без изменений."
    },
    "Left": {
      "Arguments": "Строка - выражение строкового типа.",
      "Description": "Left(Строка, Количество_символов)",
      "Output": "Возвращает заданное количество символов левой части строки."
    },
    "LevDist": {
      "Arguments": "Строка1,\nСтрока2 - выражения строкового типа.",
      "Description": "LevDist(Строка1, Строка2)",
      "Output": "Функция возвращает значение расстояния Левенштейна для строк Строка1, Строка2. Расстояние Левенштейна также называют расстоянием редактирования, которое является мерой похожести двух строк. Результат - это минимальное количество операций удалений, вставки и замены символа, которое нужно произвести, чтобы преобразовать одну строку в другую."
    },
    "Ln": {
      "Arguments": "Аргумент - положительное числовое выражение.",
      "Description": "Ln(Аргумент)",
      "Output": "Возвращает натуральный логарифм аргумента."
    },
    "Log": {
      "Arguments": "Основание - числовое выражение;\nАргумент - положительное числовое выражение.",
      "Description": "Log(Основание, Аргумент)",
      "Output": "Возвращает логарифм аргумента с заданным основанием."
    },
    "Lower": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "Lower(Аргумент)",
      "Output": "Возвращает аргумент в нижнем регистре."
    },
    "Max": {
      "Arguments": "Аргумент1,\nАргумент2,\n... - числовые выражения.",
      "Description": "Max(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает максимальное из аргументов."
    },
    "MillisecondsBetween": {
      "Arguments": "Дата1, Дата2 - аргументы типа Дата/Время.\nАбсолютное_Значение - необязательный параметр логического типа.",
      "Description": "MillisecondsBetween(Дата1, Дата2[, Абсолютное_Значение = True])",
      "Output": "Возвращает количество полных миллисекунд между двумя датами.\nЕсли Дата2 раньше Дата1 и Абсолютное_Значение = False, то будет возвращено отрицательное число полных временных промежутков между датами; если Абсолютное_значение = True, то функция вернёт модуль значения"
    },
    "Min": {
      "Arguments": "Аргумент1,\nАргумент2,\n... - числовые выражения.",
      "Description": "Min(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает минимальное из аргументов."
    },
    "Minute": {
      "Arguments": "ДатаВремя - аргумент типа Дата/Время.",
      "Description": "Minute(ДатаВремя)",
      "Output": "Возвращает минуты по заданной дате/времени."
    },
    "MinutesBetween": {
      "Arguments": "Дата1, Дата2 - аргументы типа Дата/Время.\nАбсолютное_Значение - необязательный параметр логического типа.",
      "Description": "MinutesBetween(Дата1, Дата2[, Абсолютное_Значение = True])",
      "Output": "Возвращает количество полных минут между двумя датами.\nЕсли Дата2 раньше Дата1 и Абсолютное_Значение = False, то будет возвращено отрицательное число полных временных промежутков между датами; если Абсолютное_значение = True, то функция вернёт модуль значения"
    },
    "Mod": {
      "Arguments": "Делимое - целое числовое выражение,\nДелитель - целое числовое выражение.",
      "Description": "Mod(Делимое, Делитель)",
      "Output": "Возвращает остаток от целочисленного деления Делимого на Делитель."
    },
    "Month": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "Month(Дата)",
      "Output": "Возвращает месяц по заданной дате."
    },
    "MonthsBetween": {
      "Arguments": "Дата1, Дата2 - аргументы типа Дата/Время.\nАбсолютное_Значение - необязательный параметр логического типа.",
      "Description": "MonthsBetween(Дата1, Дата2[, Абсолютное_Значение = True])",
      "Output": "Возвращает количество полных месяцев между двумя датами.\nЕсли Дата2 раньше Дата1 и Абсолютное_Значение = False, то будет возвращено отрицательное число полных временных промежутков между датами; если Абсолютное_значение = True, то функция вернёт модуль значения"
    },
    "MovingAverage": {
      "Arguments": "Аргументы - значения числового ряда",
      "Description": "MovingAverage(X{t}, X{t-1} ...)",
      "Output": "Применяется для построения пользовательской модели простого скользящего среднего в пользовательских моделях.\n\nФормула вычисления скользящего среднего:\nMA = (X(t) + ... + X(t - n))/n. "
    },
    "Now": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Now()",
      "Output": "Возвращает текущую дату и время.\nТак как текущая дата и время - это время вычисления выражения, которое считается каждый раз при получении значения этого выражения, например, при просмотре результата в виде таблицы или при выполнении экспорта данных, то можно, при наличии параметра выражения \"Кэшировать\" включить эту опцию."
    },
    "Null": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Null()",
      "Output": "Функция возвращает пустое значение."
    },
    "NVL": {
      "Arguments": "Выражение - любое строковое или числовое выражение.\nЗначение_по_умолчанию - необязательный параметр, строковое или числовое выражение, значение которого возвращается, если Выражение равно Null.",
      "Description": "NVL(Выражение [, Значение_по_умолчанию = \"\"])",
      "Output": "Возвращает значение Выражения, если оно не равно Null, и Значение_по_умолчанию в противном случае."
    },
    "NVLF": {
      "Arguments": "ЧисловоеВыражение - исходное выражение, которое может быть числом или Null.\nЗначение_по_умолчанию - необязательный параметр, числовое выражение, значение которого возвращается, если ЧисловоеВыражение равно Null.",
      "Description": "NVLF(ЧисловоеВыражение [, Значение_по_умолчанию = 0])",
      "Output": "Возвращает ЧисловоеВыражение, если оно не равно Null, и Значение_по_умолчанию в противном случае."
    },
    "Pi": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Pi()",
      "Output": "Возвращает значение константы \"ПИ\" 3.1415926535897932385."
    },
    "Pow": {
      "Arguments": "Аргумент - числовое выражение;\nСтепень - числовое выражение;",
      "Description": "Pow(Аргумент, Степень)",
      "Output": "Возвращает аргумент в заданной степени."
    },
    "Random": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Random()",
      "Output": "Возвращает псевдослучайное равномерно распределенное число, большее или равное 0 и меньше 1.\nТак как случайное число будет генерироваться каждый раз при получении значения выражения, например, при просмотре результата в виде таблицы или при выполнении экспорта данных, то в общем случае рекомендуется при наличии параметра выражения \"Кэшировать\" включить эту опцию."
    },
    "RelErr": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "RelErr(Аргумент1, Аргумент2)",
      "Output": "Возвращает относительную погрешность двух аргументов."
    },
    "Repeat": {
      "Arguments": "Строка - строковое выражение.\nКоличество_повторов - целое выражение",
      "Description": "Repeat(Строка, Количество_повторов)",
      "Output": "Возвращает строку - повторяющую заданную строку необходимое количество раз."
    },
    "Replace": {
      "Arguments": "Строка - строка, в которой необходимо сделать замену;\nСтарый_шаблон - заменяемая подстрока;\nНовый_шаблон - строка, на которую будет заменяться Старый шаблон;\nЗаменять_все - флаг замены всех вхождений Старого шаблона на Новый шаблон. Аргумент логического типа;\nИгнорировать_регистр - флаг чувствительности к регистру при замене. Аргумент логического типа.",
      "Description": "Replace(Строка, Старый_шаблон, Новый_шаблон [, Заменять_все, Игнорировать_регистр])",
      "Output": "Функция возвращает Строку, в которой вхождения Старого шаблона были заменены на Новый шаблон.\n Если флаг \"Заменять все\" имеет значение True (истина), то в возвращаемой строке будут заменены все вхождения Старого Шаблона на Новый шаблон.\n Если флаг \"Заменять все\" имеет значение False (ложь), то в возвращаемой строке будет заменено только первое по порядку вхождение.\n Если флаг \"Игнорировать регистр\" имеет значение True (истина), то поиск заменяемых фрагментов (Старый шаблон) будет регистронезависимым.\n Если флаг \"Игнорировать регистр\" имеет значение False (ложь), то поиск заменяемых фрагментов (Старый шаблон) будет регистрозависимым.\n Последние два параметра можно не указывать.\n Если не указан флаг \"Игнорировать регистр\", то поиск заменяемых фрагментов будет регистрозависимым .\n Если не указан флаг \"Заменять все\", то будет заменено только первое вхождение заменяемой подстроки.\n Например, Replace(\"A000a00A\", \"A\", \"B\", True, True) вернет строку \"B000B00B\" , т.е. заменит все вхождения строки \"A\" на строку \"B\" игнорируя регистр символов;\n Replace(\"A000a00A\", \"A\", \"B\", True, False) вернет строку \"B000a00B\".\n Replace(\"A000a00A\", \"A\", \"B\") вернет строку \"B000a00A\"."
    },
    "Right": {
      "Arguments": "Строка - выражение строкового типа.",
      "Description": "Right(Строка, Количество_символов)",
      "Output": "Возвращает заданное количество символов правой части строки."
    },
    "Round": {
      "Arguments": "Аргумент1 - числовое выражение,\nАргумент2 - необязательный параметр, количество цифр после запятой, целое число.",
      "Description": "Round(Аргумент1 [, Аргумент2 = 0])",
      "Output": "Округляет вещественное число до ближайшего числа, имеющего указанное количество цифр после запятой."
    },
    "RoundDown": {
      "Arguments": "Аргумент1 - числовое выражение,\nАргумент2 - необязательный параметр, количество цифр после запятой, целое число.",
      "Description": "RoundDown(Аргумент1 [, Аргумент2 = 0])",
      "Output": "Округляет вещественное число вниз до числа, имеющего указанное количество цифр после запятой."
    },
    "RoundUp": {
      "Arguments": "Аргумент1 - числовое выражение,\nАргумент2 - необязательный параметр, количество цифр после запятой, целое число.",
      "Description": "RoundUp(Аргумент1 [, Аргумент2 = 0])",
      "Output": "Округляет вещественное число вверх до числа, имеющего указанное количество цифр после запятой."
    },
    "Second": {
      "Arguments": "ДатаВремя - аргумент типа Дата/Время.",
      "Description": "Second(ДатаВремя)",
      "Output": "Возвращает секунды по заданной дате/времени."
    },
    "SecondsBetween": {
      "Arguments": "Дата1, Дата2 - аргументы типа Дата/Время.\nАбсолютное_Значение - необязательный параметр логического типа.",
      "Description": "SecondsBetween(Дата1, Дата2[, Абсолютное_Значение = True])",
      "Output": "Возвращает количество полных секунд между двумя датами.\nЕсли Дата2 раньше Дата1 и Абсолютное_Значение = False, то будет возвращено отрицательное число полных временных промежутков между датами; если Абсолютное_значение = True, то функция вернёт модуль значения"
    },
    "Sign": {
      "Arguments": "Аргумент - числовое выражение;",
      "Description": "Sign(Аргумент)",
      "Output": "Возвращает знак аргумента."
    },
    "Sin": {
      "Arguments": "Угол - значение угла в радианах.",
      "Description": "Sin(Угол)",
      "Output": "Возвращает синус заданного угла."
    },
    "Space": {
      "Arguments": "Количество_пробелов - целое выражение.",
      "Description": "Space(Количество_пробелов)",
      "Output": "Возвращает заданное количество пробелов."
    },
    "Sqrt": {
      "Arguments": "Аргумент - положительное числовое выражение.",
      "Description": "Sqrt(Аргумент)",
      "Output": "Возвращает квадратный корень аргумента."
    },
    "StartOfInterval": {
      "Arguments": "Дата - аргумент типа Дата/Время.\nКоличество_Интервалов - количество интервалов заданного типа, составляющих интервал; целое положительное число.\nТип_Интервала - тип временного интервала.\nНачальная_Точка - аргумент типа Дата/Время, от которого начинают отсчитываться временные интервалы.\nТип_Интервала может принимать следующие значения:\n \"Year\" - интервал задан в годах (начало отсчёта по умолчанию - 0 год);\n \"Quarter\" - интервал задан в кварталах (начало отсчёта по умолчанию - первый квартал 1 года);\n \"Month\" - интервал задан в месяцах (начало отсчёта по умолчанию - январь 1 года);\n \"Week\" - интервал задан в неделях (начало отсчёта по умолчанию - 1 января 1900 года);\n \"Day\" - интервал задан в днях (начало отсчёта по умолчанию - 30 декабря 1899 года);\n \"Hour\" - интервал задан в часах (начало отсчёта по умолчанию - полночь 30 декабря 1899 года);\n \"Minute\" - интервал задан в минутах (начало отсчёта по умолчанию - полночь 30 декабря 1899 года);\n \"Second\" - интервал задан в секундах (начало отсчёта по умолчанию - полночь 30 декабря 1899 года).",
      "Description": "StartOfInterval(Дата, Количество_Интервалов, Тип_Интервала[, Начальная_Точка])",
      "Output": "Функция возвращает начало указанного временного интервала.\nПродолжительность интервала определяется параметрами Тип_Интервала и Количество_Интервалов.\nЕсли параметр Начальная_Точка задан, то интервалы отсчитываются от начала интервала заданного типа, к которому относится Начальная_Точка.\nНапример, если Тип_Интервала - месяц, а Начальная_Точка - 15 ноября 2023 года, то интервалы будут рассчитаны относительно 1 ноября 2023 года"
    },
    "StartOfTheMonth": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "StartOfTheMonth(Дата)",
      "Output": "Функция возвращает дату начала месяца, указанного в Дата"
    },
    "StartOfTheQuarter": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "StartOfTheQuarter(Дата)",
      "Output": "Функция возвращает дату начала квартала, к которому относится указанная Дата"
    },
    "StartOfTheWeek": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "StartOfTheWeek(Дата)",
      "Output": "Функция возвращает дату начала указанной недели в соответствии со стандартом ISO 8601, по которому неделя начинается с понедельника и заканчивается воскресеньем."
    },
    "StartOfTheYear": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "StartOfTheYear(Дата)",
      "Output": "Функция возвращает дату начала года, указанного в Дата"
    },
    "StdDev": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "StdDev(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает стандартное отклонение аргументов."
    },
    "Str": {
      "Arguments": "Аргумент - выражение числового типа.",
      "Description": "Str(Аргумент)",
      "Output": "Возвращает строковое представление Аргумента с учётом локали."
    },
    "StrToDate": {
      "Arguments": "Аргумент - строковое выражение, содержащее дату/время\nФормат - необязательный параметр формат даты/время в терминах D, M, Y, H, N, S, Z",
      "Description": "StrToDate(Аргумент [, Формат])",
      "Output": "Функция конвертирует строку, содержащую дату в формат типа \"Дата/Время\".\nПримеры формата:\n  \"DD.MM.YY\" - определяет, что Аргумент содержит строки вида \"25.12.04\";\n  \"DD/MM/YY HH:NN:SS\" - определяет, что Аргумент содержит строки вида \"25/12/04 12:44:54\";"
    },
    "StrZero": {
      "Arguments": "Выражение - числовое выражение.\nОбщая_длина - длина результирующей строки",
      "Description": "StrZero(Выражение, Общая_длина)",
      "Output": "Добавляет спереди заданного выражения нули так, чтобы длина результирующей строки равнялась Общей_длине."
    },
    "Stuff": {
      "Arguments": "Источник - строковое выражение.\nВставляемая_строка - строковое выражение.\nНачало - позиция начала вставки\nДлина - длина удаляемой подстроки",
      "Description": "Stuff(Источник, Начало, Длина [, Вставляемая_строка = \"\"])",
      "Output": "Возвращает строку следующего вида. Сначала из Источника удаляется подстрока, начиная с позиции Начало длиной Длина. Затем на место удаленной подстроки вставляется Вставляемая_строка."
    },
    "SubStr": {
      "Arguments": "Источник - строковое выражение.\nНачало - позиция начало подстроки\nДлина - длина подстроки",
      "Description": "SubStr(Источник, Начало, Длина)",
      "Output": "Возвращает подстроку из строки - источника, начиная с позиции Начало длиной Длина."
    },
    "Sum": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "Sum(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает сумму аргументов."
    },
    "SumSq": {
      "Arguments": "Аргументы - любые числовые выражения.",
      "Description": "SumSq(Аргумент1, Аргумент2 ...)",
      "Output": "Возвращает сумму квадратов аргументов."
    },
    "Tan": {
      "Arguments": "Угол - значение угла в радианах.",
      "Description": "Tan(Угол)",
      "Output": "Возвращает тангенс заданного угла."
    },
    "Today": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Today()",
      "Output": "Возвращает текущую дату.\nТак как текущая дата - это дата вычисления выражения, которое считается каждый раз при получении значения этого выражения, например, при просмотре результата в виде таблицы или при выполнении экспорта данных, то можно, при наличии параметра выражения \"Кэшировать\" включить эту опцию."
    },
    "Trim": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "Trim(Аргумент)",
      "Output": "Возвращает Аргумент без ведущих и ведомых пробелов."
    },
    "TrimLeft": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "TrimLeft(Аргумент)",
      "Output": "Возвращает Аргумент без ведущих пробелов."
    },
    "TrimRight": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "TrimRight(Аргумент)",
      "Output": "Возвращает Аргумент без ведомых пробелов."
    },
    "UnixToDateTime": {
      "Arguments": "UnixВремя - целое число секунд, прошедших с 1970-01-01T00:00:00Z;\nВернуть_В_UTC - необязательный аргумент логического типа.",
      "Description": "UnixToDateTime(UnixВремя[, Вернуть_В_UTC = True])",
      "Output": "Возвращает дату и время по заданному Unix-времени.\nЕсли Вернуть_В_UTC = False, то результат вызова функции будет приведён к местному времени."
    },
    "Upper": {
      "Arguments": "Аргумент - строковое выражение.",
      "Description": "Upper(Аргумент)",
      "Output": "Возвращает аргумент в верхнем регистре."
    },
    "Val": {
      "Arguments": "Строка - строковое выражение.\nДесятичный_Разделитель - необязательный параметр строкового типа, используемый в качестве разделителя между целой и дробной частью числа. По умолчанию преобразование производится с учётом десятичного разделителя текущей локали пакета. Десятичный_Разделитель должен иметь длину в один символ.\nРазделитель_Групп_Разрядов - необязательный параметр строкового или логического типа, используемый для разделения групп разрядов в больших числах. Если Разделитель_Групп_Разрядов имеет строковый тип данных, то он должен быть длиной в один символ.",
      "Description": "Val(Строка[, Десятичный_Разделитель, Разделитель_Групп_Разрядов = True])",
      "Output": "Преобразует заданную строку в число с учётом параметров Десятичный_Разделитель и Разделитель_Групп_Разрядов.\nЕсли Разделитель_Групп_Разрядов не задан или равен True (истина), преобразование производится с учётом разделителя групп разрядов, указанного в текущей локали пакета. Если Разделитель_Групп_Разрядов равен False (ложь), то преобразование производится без учёта разделителей групп разрядов.\nДля параметров Десятичный_Разделитель и Разделитель_Групп_Разрядов допустимы все символы ASCII, кроме цифр, знаков + - и буквы E. Для Разделитель_Групп_Разрядов также допустим символ NBSP.\nЕсли параметры Десятичный_Разделитель и Разделитель_Групп_Разрядов заданы, то их значения не должны совпадать.\nЕсли задан только параметр Десятичный_Разделитель, то он не должен совпадать с разделителем групп разрядов, указанным в текущей локали пакета."
    },
    "Week": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "Week(Дата)",
      "Output": "Возвращает номер недели в году по заданной дате в соответствии со стандартом ISO 8601, по которому неделя начинается с понедельника и заканчивается воскресеньем. Первой неделей года считается первая неделя по Григорианскому календарю, в которой есть четверг."
    },
    "Year": {
      "Arguments": "Дата - аргумент типа Дата/Время.",
      "Description": "Year(Дата)",
      "Output": "Возвращает год по заданной дате."
    },
    "YearsBetween": {
      "Arguments": "Дата1, Дата2 - аргументы типа Дата/Время.\nАбсолютное_Значение - необязательный параметр логического типа.",
      "Description": "YearsBetween(Дата1, Дата2[, Абсолютное_Значение = True])",
      "Output": "Возвращает количество полных лет между двумя датами.\nЕсли Дата2 раньше Дата1 и Абсолютное_Значение = False, то будет возвращено отрицательное число полных временных промежутков между датами; если Абсолютное_значение = True, то функция вернёт модуль значения"
    }
  },
  "RegExFunctions": {
    "RegExDomain": {
      "Arguments": "Вх.Строка - входная строка, в которой будет искаться домен;\nНом.Вхожд - порядковый номер домена в искомой строке.",
      "Description": "RegExDomain(Вх.Строка [, Ном.Вхожд = 1])",
      "Output": "Возвращает Ном.Вхожд-ое доменное имя из строки Вх.Строка, не включая www до домена 1-го уровня включительно.\nДля поиска используются регулярные выражения."
    },
    "RegExEmail": {
      "Arguments": "Вх.Строка - входная строка, в которой будет искаться email адрес;\nНом.Вхожд - порядковый номер email адреса в искомой строке.",
      "Description": "RegExEmail(Вх.Строка [, Ном.Вхожд = 1])",
      "Output": "Извлекает Ном.Вхожд-й email адрес из строки Вх.Строка.\nДля поиска используются регулярные выражения."
    },
    "RegExMatch": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка.",
      "Description": "RegExMatch(Рег.Выр., Строка)",
      "Output": "Проверяет соответствие строки регулярному выражению.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExMatchCount": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка.",
      "Description": "RegExMatchCount(Рег.Выр., Строка)",
      "Output": "Возвращает кол-во частей строки, соответствующих регулярному выражению.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExMatchedExp": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка;\nНомерЧасти - порядковый номер соответствующей регулярному выражению части входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.",
      "Description": "RegExMatchedExp(Рег.Выр., Строка [, НомерЧасти = 1])",
      "Output": "Возвращает часть строки, соответствующую регулярному выражению.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExMatchedNamedSubExp": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка;\nИмяГруппы - имя группы, определяемой метасимволами (...);\nНомерЧасти - порядковый номер соответствующей регулярному выражению части входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.",
      "Description": "RegExMatchedNamedSubExp(Рег.Выр., Строка, ИмяГруппы [, НомерЧасти = 1])",
      "Output": "Возвращает именованную группу части строки, соответствующую регулярному выражению.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExMatchedSubExp": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nСтрока - входная строка;\nНомерГруппы - порядковый номер группы, определяемой метасимволами (...);\nНомерЧасти - порядковый номер соответствующей регулярному выражению части входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount.",
      "Description": "RegExMatchedSubExp(Рег.Выр., Строка, НомерГруппы [, НомерЧасти = 1])",
      "Output": "Возвращает группу части строки, соответствующую регулярному выражению.\nГруппы нумеруются слева направо, в порядке появления открывающихся скобок.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExReplace": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nВх.Строка - входная строка, которая будет подвержена замене;\nСтрокаЗамены - строка, которая будет вставлена вместо части входной строки, соответствующией регулярному выражению;\nНомерЧасти - порядковый номер соответствующей регулярному выражению части входной строки. Параметр должен входить в диапазон от 1 до RegExMatchCount;\nРасш.Синтаксис - расширенный синтаксис замены (используется библиотека PCRE2).",
      "Description": "RegExReplace(Рег.Выр., Вх.Строка, СтрокаЗамены [, НомерЧасти = 1, Расш.Синтаксис = False])",
      "Output": "Возвращает Вх.Строка, в которой НомерЧасти-ое вхождение выражения Рег.Выр. будет заменено на СтрокаЗамены.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    },
    "RegExReplaceAll": {
      "Arguments": "Рег.Выр. - строка регулярного выражения;\nВх.Строка - входная строка, которая будет подвержена замене;\nСтрокаЗамены - строка, которая будет вставлена вместо частей входной строки, соответствующих регулярному выражению;\nРасш.Синтаксис - расширенный синтаксис замены (используется библиотека PCRE2).",
      "Description": "RegExReplaceAll(Рег.Выр., Вх.Строка, СтрокаЗамены [, Расш.Синтаксис = False])",
      "Output": "Возвращает Вх.Строка, в которой все вхождения выражения Рег.Выр. будут заменены на СтрокаЗамены.\nИспользуется библиотека PCRE2. Синтаксис и семантика совместимы с регулярными выражениями Perl."
    }
  },
  "StatFunctions": {
    "DKhi2": {
      "Arguments": "Степени_свободы - число степеней свободы.\nАргумент - значение, для которого требуется вычислить плотность вероятности.",
      "Description": "DKhi2(Степени_свободы, Аргумент)",
      "Output": "Функция плотности распределения хи-квадрат. Возвращает плотность вероятности."
    },
    "FKhi2": {
      "Arguments": "Степени_свободы - число степеней свободы.\nАргумент - значение, для которого требуется вычислить вероятность.",
      "Description": "FKhi2(Степени_свободы, Аргумент)",
      "Output": "Функция распределения хи-квадрат. Возвращает левостороннюю вероятность распределения хи-квадрат P(X <= Аргумент)."
    },
    "InvKhi2": {
      "Arguments": "Степени_свободы - число степеней свободы.\nВероятность - значение функции распределения хи-квадрат.",
      "Description": "InvKhi2(Степени_свободы, Вероятность)",
      "Output": "Функция, обратная функции распределения хи-квадрат. Возвращает пороговое значение x, для которого функция вероятности имеет значение Вероятность. Если p=FKhi2(N, x), то InvKhi2(N, p) = x."
    },
    "PKhi2": {
      "Arguments": "Степени_свободы - число степеней свободы.\nАргумент - значение, для которого требуется вычислить вероятность.",
      "Description": "PKhi2(Степени_свободы, Аргумент)",
      "Output": "Дополнительная функция распределения хи-квадрат. Возвращает правостороннюю вероятность распределения хи-квадрат P(X > Аргумент)."
    }
  },
  "TreeFunctions": {
    "DisplayName": {
      "Arguments": "ПутьУзла - путь узла, переменной или выражения",
      "Description": "DisplayName([\"ПутьУзла\"])",
      "Output": "Функция возвращает метку (отображаемое имя) по пути узла, переменной или выражения.\nЕсли функция вызывается без аргументов, то она возвращает метку текущего вычисляемого выражения.\nПримечание: ПутьУзла - строковое значение, т.е. явно заданное ПутьУзла должно быть указано в кавычках.\nНапример: DisplayName(\"Root.Node1\")"
    },
    "ItemCount": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "ItemCount()",
      "Output": "Функция возвращает число выражений внутри массива."
    },
    "ItemIndex": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "ItemIndex()",
      "Output": "Функция возвращает индекс выражения внутри массива. Нумерация начинается с 0."
    },
    "Location": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Location()",
      "Output": "Функция возвращает путь от корня дерева до выражения."
    },
    "Parent": {
      "Arguments": "Аргументы отсутствуют.",
      "Description": "Parent()",
      "Output": "Функция возвращает родительский узел текущего узла выражения."
    }
  },
  "VariablesFunctions": {
    "DisplayName": {
      "Arguments": "ИмяПеременной - имя переменной или выражения",
      "Description": "DisplayName([\"ИмяПеременной\"])",
      "Output": "Функция возвращает метку (отображаемое имя) по имени переменной или выражения.\nЕсли функция вызывается без аргументов, то она возвращает метку текущего вычисляемого выражения.\nПримечание: ИмяПеременной - строковое значение, т.е. явно заданное ИмяПеременной должно быть указано в кавычках.\nНапример: DisplayName(\"VAR1\")"
    }
  }
}