{
  "CryptFunctions": {
    "CRC32": {
      "Arguments": "String - a string for which the CRC32 value is calculated.",
      "Description": "CRC32(String)",
      "Output": "Function returns a CRC32 checksum calculated for a given string.\nThe calculations operate the UTF-8 encoded sequence of the string's characters."
    },
    "HardKey": {
      "Arguments": "Arguments are absent.",
      "Description": "HardKey()",
      "Output": "Function returns the serial number of the dongle key."
    },
    "MD5": {
      "Arguments": "String - a string for which the MD5 value is calculated.",
      "Description": "MD5(String)",
      "Output": "Function returns HEX value MD5 calculated on the basis of the given string.\nCalculations are performed with the String characters sequence using UTF-8 encoding."
    },
    "SHA1": {
      "Arguments": "String - a string for which the SHA1 value is calculated.",
      "Description": "SHA1(String)",
      "Output": "Function returns HEX value SHA1 calculated on the basis of the given string.\nCalculations are performed with the String characters sequence using UTF-8 encoding."
    }
  },
  "DataFunctions": {
    "CumulativeSum": {
      "Arguments": "FieldName - the field for which the cumulative sum needs to be obtained\nGroupFieldName - the field by which data is grouped. This is an optional parameter. If this parameter is set, cumulative sums get calculated within groups.",
      "Description": "CumulativeSum(\"FieldName\" [, \"GroupFieldName\"])",
      "Output": "Function returns the cumulative sum according to the field.\nNote: FieldName and GroupFieldName are string values, namely, the explicitly given FieldName and GroupFieldName must be specified in quotation marks.\nFor example: CumulativeSum(\"COL1\", \"COL2\")"
    },
    "Data": {
      "Arguments": "FieldName - the name of the field to retrieve data from\nRowNumber - the number of the row from which to retrieve the value. Row numbering starts from 0.",
      "Description": "Data(\"FieldName\",RowNumber)",
      "Output": "Function returns the FieldName field value taken from the RowNumber row.\nIn case of the recursive usage of this function, the \"Cache\" checkbox in the \"Expression parameters\" window must be marked.\nNote: FieldName is a string value, therefore, an explicitly given FieldName must be put in quotes.\nFor example, Data(\"COL1\", 2)"
    },
    "DisplayName": {
      "Arguments": "FieldName - name of field, variable or expression",
      "Description": "DisplayName([\"FieldName\"])",
      "Output": "Function returns the caption (display name) according to the field name, variable or expression.\nIf the function is called without arguments, it returns the caption of the current calculated expression.\nNote: FieldName - the string value, namely, the explicitly given FieldName must be specified in quotation marks.\nFor example: DisplayName(\"COL1\")"
    },
    "RowCount": {
      "Arguments": "Arguments are absent.",
      "Description": "RowCount()",
      "Output": "Function returns the row count in the data source."
    },
    "RowNum": {
      "Arguments": "Arguments are absent.",
      "Description": "RowNum()",
      "Output": "Function returns the current row number of the data source. Row numbering starts from 0."
    },
    "Stat": {
      "Arguments": "FieldName - the field for which to obtain the indicator value\nType - the statistics indicator to be obtained",
      "Description": "Stat(\"FieldName\", \"Type\")",
      "Output": "Function returns the value of one of the statistical indicators.\nThe type can adopt one of the following values:\n       Min - minimum value\n       Max - maximum value\n       Avg - average value\n       StdDev - standard deviation\n       Sum - sum of values\n       SumSq - sum of square values\n       Count - count of values\n       UniqueCount - count of unique values\n       NullCount - count of null values\n       Mode - most frequently occurring value\nNote: FieldName and Type - string values, namely, explicitly given FieldName and Type must be in quotation marks.\nFor example: Stat(\"COL1\", \"Min\")"
    }
  },
  "Functions": {
    "Abs": {
      "Arguments": "Argument - numeric expression.",
      "Description": "Abs(Argument)",
      "Output": "Returns the absolute value of argument."
    },
    "AbsErr": {
      "Arguments": "Arguments - any numeric expressions.",
      "Description": "AbsErr(Argument1, Argument2)",
      "Output": "Returns the absolute error of two arguments."
    },
    "AddDay": {
      "Arguments": "Date - a Date\/Time type argument\nNumber - an argument of the integer type.",
      "Description": "AddDay(Date, Number)",
      "Output": "The function returns the value of argument Date increased by the specified Number of days. The number can also be negative, in this case, the function returns an earlier date by subtracting the specified number of days from the given date."
    },
    "AddHour": {
      "Arguments": "Date - a Date\/Time type argument\nNumber - an argument of the integer type.",
      "Description": "AddHour(Date, Number)",
      "Output": "The function returns the value of the argument Date increased by the specified Number of hours. The number can also be negative, in this case, the function returns the relevant earlier date by subtracting the specified number of hours from the given date."
    },
    "AddMillisecond": {
      "Arguments": "Date - a Date\/Time type argument\nNumber - an argument of the integer type.",
      "Description": "AddMillisecond(Date, Number)",
      "Output": "The function returns the value of the argument Date increased by the specified Number of milliseconds. The number can also be negative, in this case, the function returns the relevant earlier date by subtracting the specified number of milliseconds from the given date."
    },
    "AddMinute": {
      "Arguments": "Date - a Date\/Time type argument\nNumber - an argument of the integer type.",
      "Description": "AddMinute(Date, Number)",
      "Output": "The function returns the value of the argument Date increased by the specified Number of minutes. The number can also be negative, in this case, the function returns the relevant earlier date by subtracting the specified number of minutes from the given date."
    },
    "AddMonth": {
      "Arguments": "Date - a Date\/Time type argument\nNumber - an argument of the integer type.",
      "Description": "AddMonth(Date, Number)",
      "Output": "Function returns the Date argument value, increased by the specified Number of months. The number can also be negative. In this case, the function will return the date to the given number of months before the specified date.\n\nIf the specified day of the month exceeds the last day of the resulting month, the function will set the date to the last day of the resulting month."
    },
    "AddQuarter": {
      "Arguments": "Date - a Date\/Time type argument\nNumber - an argument of the integer type.",
      "Description": "AddQuarter(Date, Number)",
      "Output": "Function returns the Date argument value, increased by the specified Number of quarters. The number can also be negative. In this case, the function will return the date to the given number of quarters before the specified date.\n\nIf the specified day of the month exceeds the last day of the resulting quarter, the function will set the date to the last day of the resulting quarter."
    },
    "AddSecond": {
      "Arguments": "Date - a Date\/Time type argument\nNumber - an argument of the integer type.",
      "Description": "AddSecond(Date, Number)",
      "Output": "The function returns the value of the argument Date increased by the specified Number of seconds. The number can also be negative, in this case, the function returns the relevant earlier date by subtracting the specified number of seconds from the given date."
    },
    "AddWeek": {
      "Arguments": "Date - a Date\/Time type argument\nNumber - an argument of the integer type.",
      "Description": "AddWeek(Date, Number)",
      "Output": "Function returns the Date argument value, increased by the specified Number of weeks. The number can also be negative. In this case, the function will return the date to the given number of weeks before the specified date."
    },
    "AddYear": {
      "Arguments": "Date - a Date\/Time type argument\nNumber - an argument of the integer type.",
      "Description": "AddYear(Date, Number)",
      "Output": "Function returns the Date argument value, increased by the specified Number of years. The number can also be negative. In this case, the function will return the date to the given number of years before the specified date."
    },
    "AMGD": {
      "Arguments": "Arguments - numeric expressions.",
      "Description": "AMGD(Cost, Residual_cost, Operating_time, Period)",
      "Output": "Returns the annual property depreciation for the specified period."
    },
    "ArcCos": {
      "Arguments": "Value - the value of the cosine whose angle should be found.",
      "Description": "ArcCos(Value)",
      "Output": "Returns the arccosine of the value, i.e., the angle in radians whose cosine is the Value."
    },
    "ArcSin": {
      "Arguments": "Value - the value of the sine whose angle should be found.",
      "Description": "ArcSin(Value)",
      "Output": "Returns the arcsine of the value, i.e., the angle in radians whose sine is the Value."
    },
    "ArcTan": {
      "Arguments": "Value - the value of the tangent whose angle should be found.",
      "Description": "ArcTan(Value)",
      "Output": "Returns the arctangent of the value, i.e., the angle in radians whose tangent is the Value."
    },
    "AutoRegression": {
      "Arguments": "C - constant,\nA0 ... An - regression coefficients,\nX(t) ... X(t-n) - series values.",
      "Description": "AutoRegression(C, A0, X{t}, A1, X{t-1} ...)",
      "Output": "Used for the construction of the user model of the following autoregression type:\nPrediction = C + A0 * X(t) + A1 * X(t-1) + ..."
    },
    "Avg": {
      "Arguments": "Arguments - any numeric expressions.",
      "Description": "Avg(Argument1, Argument2 ...)",
      "Output": "Returns the arithmetic mean of arguments."
    },
    "Chr": {
      "Arguments": "Argument - numerical code of Unicode character.",
      "Description": "Chr(Argument)",
      "Output": "Returns Unicode character according to its code."
    },
    "Concat": {
      "Arguments": "String - string expression.",
      "Description": "Concat(String, String [, ... String])",
      "Output": "Combines several strings into one.\nNull values are interpreted as the strings with zero length, namely, as \"\"."
    },
    "Cos": {
      "Arguments": "Angle - angle value in radians.",
      "Description": "Cos(Angle)",
      "Output": "Returns the cosine of the set angle."
    },
    "Count": {
      "Arguments": "String - string expression.",
      "Description": "Count(String)",
      "Output": "Returns count of characters in the string."
    },
    "CreateGUID": {
      "Arguments": "Format - method of GUID string representation (\"N\", \"D\", \"B\", \"P\").\nUpperCase - argument of the logical type defining the character case of hexadecimal digits.",
      "Description": "CreateGUID([Format = \"B\", UpperCase = True])",
      "Output": "Function returns GUID string representation in the specified format:\n  \"N\" - 32 digits;\n  \"D\" - 32 hyphenated digits;\n  \"B\" - 32 hyphenated digits and digits in curved brackets;\n  \"P\" - 32 hyphenated digits and digits in round brackets.\nIf the format is not specified, use of \"B\" format is required. By default, hexadecimal digits are written in uppercase.\nAs GUID will be generated each time when getting the expression value, for example, when viewing result in the tabular form or executing data export, it is generally recommended to activate this option if there is \"Cache\" expression parameter."
    },
    "DamLevDist": {
      "Arguments": "String1,\nString2 - expressions of the string type.",
      "Description": "DamLevDist(String1, String2)",
      "Output": "The function returns the Damerau–Levenshtein distance for strings String1, String2. The Damerau–Levenshtein distance is a metric of similarity between two strings, an edit distance that allows transposition. The value returned is the minimum number of operations (consisting of insertions, deletions or substitutions of a single character, or transposition of two adjacent characters) required to change one string into the other."
    },
    "DateTimeToStr": {
      "Arguments": "Date_time - expression of the Date\/Time type.\nDate_format - optional parameter date format in terms of D, M, Y.\nTime_format - optional parameter time format in terms of H, N, S, Z.",
      "Description": "DateTimeToStr(Date_time [, Date_format [, Time_format]])",
      "Output": "Returns the string representation of the Date_time argument.\nExamples of the date format:\n  \"DD.MM.YY\" - converts the date into the \"day.month.year\" format (\"25.12.04\")\n  \"MM\/DD\/YYYY\" - converts the date into the \"month.day.year\" format (\"12\/25\/2004\")\nExamples of the time format:\n  \"H:NN\" - converts the time into the \"hours:minutes\" format (\"9:53\")\n  \"HH:NN:SS\" - converts the time into the \"hours:minutes:seconds\" format (\"09:05:53\")"
    },
    "DateToStr": {
      "Arguments": "Date - expression of the Date\/Time type.\nFormat - optional parameter date format in terms of D, M, Y.",
      "Description": "DateToStr(Date [, Format])",
      "Output": "Returns the string representation of the Date argument.\nExamples of the date format:\n  \"DD.MM.YY\" - converts the date into the \"day.month.year\" format (\"25.12.04\")\n  \"MM\/DD\/YYYY\" - converts the date into the \"month.day.year\" format (\"12\/25\/2004\")"
    },
    "Day": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "Day(Date)",
      "Output": "Returns the day according to the specified date."
    },
    "DayOfWeek": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "DayOfWeek(Date)",
      "Output": "Returns the week day according to the specified date."
    },
    "DaysBetween": {
      "Arguments": "Date1, Date2 - Date\/Time type arguments.\nAbsolute_Value - an optional boolean parameter.",
      "Description": "DaysBetween(Date1, Date2[, Absolute_Value = True])",
      "Output": "Returns the number of complete days between two dates.\nIf Date2 is earlier than Date1 and Absolute_Value = False, the function will return the negative number of complete time spans between the dates; if Absolute_Value = True, the function will return the absolute value"
    },
    "Decode": {
      "Arguments": "Expression - the expression value of which is alternately compared with the values of the ValueN arguments.\nValueN - the expression value of which is compared with the Expression argument.\nResultN - the expression of the string type that is returned if the Expression = ValueN.\nDefault_value - the expression of the string type the result of which is returned if the Expression is equal to none of the ValuesN (if it is not stated then it is equal to \"\").",
      "Description": "Decode(Expression, Value1, Result1 [, Value2, Result2]... [, Default_value = \"\"])",
      "Output": " Implements IF - THEN - ELSE feature and the function result is related to the string type.\n All ResultN expressions are calculated before the Expression and ValueN comparison."
    },
    "DecodeF": {
      "Arguments": "Expression - any numeric expression value of which is used for comparison.\nError - the numeric expression, comparison error.\nValueN - the numeric expression value of which is compared with the Expression argument.\nResultN - the value that is returned if |ValueN - ExpressionN| <= Error.\nDefault_value - the numeric expression the result of which is returned if none of the ValuesN is equal to the Expression (by default 0).",
      "Description": "DecodeF(Expression, Error, Value1, Result1 [, Value2, Result2]... [, Default_value = 0])",
      "Output": " Implements IF - THEN - ELSE feature and the function result as all its arguments are related to the numeric or Date\/Time type.\n All ResultN expressions are calculated before the Expression and ValueN comparison."
    },
    "DecodeN": {
      "Arguments": "Expression - the expression value of which is alternately compared with the values of the ValueN arguments.\nValueN - the expression value of which is compared with the Expression argument.\nResultN - the expression of the numeric or Date\/Time type that is returned if the Expression = ValueN.\nDefault_value - the expression of the numeric or Date\/Time type the result of which is returned, if the Expression is equal to none of the ValuesN (if it is not stated then it is equal to 0).",
      "Description": "DecodeN(Expression, Value1, Result1 [, Value2, Result2]... [, Default_value = 0])",
      "Output": " Implements IF - THEN - ELSE feature and the function result is related to the numeric or Date\/Time type.\n All ResultN expressions are calculated before the Expression and ValueN comparison."
    },
    "DecodeS": {
      "Arguments": "Expression - the expression value of which is alternately compared with the values of the ValueN arguments.\nValueN - the expression value of which is compared with the Expression argument.\nResultN - the expression of the string type that is returned if the Expression = ValueN.\nDefault_value - the expression of the string type the result of which is returned if the Expression is equal to none of the ValuesN (if it is not stated then it is equal to \"\").",
      "Description": "DecodeS(Expression, Value1, Result1 [, Value2, Result2]... [, Default_value = \"\"])",
      "Output": " Implements IF - THEN - ELSE feature and the function result is related to the string type.\n All ResultN expressions are calculated before the Expression and ValueN comparison."
    },
    "DecodeV": {
      "Arguments": "Expression - the expression value of which is alternately compared with the values of the Value arguments.\nValue - the expression value of which is compared with the Expression argument.\nResult - the expression that is returned if the Expression = Value.\nDefault_value - the expression, the result of which is returned if the Expression is equal to none of the Values (if it is not stated then it is equal to Null).",
      "Description": "DecodeV(Expression, Value, Result [, Value, Result]... [, Default_value = Null])",
      "Output": " Implements IF - THEN - ELSE feature.\n All Result expressions are calculated before the Expression and Values comparison"
    },
    "Div": {
      "Arguments": "Dividend - integer numeric expression,\nDivisor - integer numeric expression.",
      "Description": "Div(Dividend, Divisor)",
      "Output": "Returns the integer division quotient of the Dividend by the Divisor."
    },
    "EncodeDate": {
      "Arguments": "Year - year in the form of a number,\nMonth - month in the form of a number,\nDay - day in the form of a number.",
      "Description": "EncodeDate(Year, Month, Day)",
      "Output": "Function returns the date formed from the specified arguments."
    },
    "EncodeDateTime": {
      "Arguments": "Year - year in the form of a number,\nMonth - month in the form of a number,\nDay - day in the form of a number,\nHours - hours in the form of a number,\nMinutes - minutes in the form of a number,\nSeconds - seconds in the form of a number.",
      "Description": "EncodeDateTime(Year, Month, Day, Hours, Minutes, Seconds)",
      "Output": "Function returns the date and time formed from the specified arguments."
    },
    "EncodeTime": {
      "Arguments": "Hours - hours in the form of a number,\nMinutes - minutes in the form of a number,\nSeconds - seconds in the form of a number.",
      "Description": "EncodeTime(Hours, Minutes, Seconds)",
      "Output": "Function returns the time formed from the specified arguments."
    },
    "EndOfTheMonth": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "EndOfTheMonth(Date)",
      "Output": "The function returns the ending date and time of the month specified in Date"
    },
    "EndOfTheQuarter": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "EndOfTheQuarter(Date)",
      "Output": "The function returns the ending date and time of the quarter to which the specified Date belongs"
    },
    "EndOfTheWeek": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "EndOfTheWeek(Date)",
      "Output": "The function returns the ending date and time of the specified week following the ISO 8601 standard, under which weeks start on Monday and end on Sunday."
    },
    "EndOfTheYear": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "EndOfTheYear(Date)",
      "Output": "The function returns the ending date and time of the year specified in Date"
    },
    "Exp": {
      "Arguments": "Degree - numeric expression.",
      "Description": "Exp(Degree)",
      "Output": "Returns e constant in the given degree."
    },
    "ExpMovingAverage": {
      "Arguments": "Arguments - values of the numeric series",
      "Description": "ExpMovingAverage(X{t}, X{t-1} ...)",
      "Output": "Used for the construction of the user model of the exponentially weighted moving average.\n\nUnlike the simple moving average, with the exponential moving average the weighting for each older datum decreases exponentially.\n\nEMA is calculated using the following recursive formula: EMA(t) = a * X(t) + (1 - a) * EMA(t-1), where EMA(k) is the value of the exponential moving average in point k and a is the smoothing factor, a = 2 \/ (n + 1), with n being the window length."
    },
    "Factorial": {
      "Arguments": "Argument - integer positive numeric expression.",
      "Description": "Factorial(Argument)",
      "Output": "Returns the argument factorial."
    },
    "Find": {
      "Arguments": "Substring - searched substring,\nString - the string in which substring is searched,\nMatchIndex - optional occurrence index of the Substring in the String to be returned. Argument of the numeric type.",
      "Description": "Find(Substring, String[, MatchIndex = 1])",
      "Output": "Function returns position of the first character of the Substring of the set MatchIndex in the String.\n The MatchIndex can be both positive and negative. If the MatchIndex is positive, the search is performed from left to right, if it is negative, the search is performed from right to left.\n If there is no occurrence of the set order, the function returns 0.\n For example, Find(\"A\", \"A000A00A\", 2) will return position of the second left occurrence of substring \"A\" to string \"A000A00A\", namely, 5;\n Find(\"A\", \"A000A00A\", -1) will return position of the first right occurrence of substring \"A\" to string \"A000A00A\", namely, 8.\n If the MatchIndex is equal to zero, the function will return the null value (Null)."
    },
    "Format": {
      "Arguments": "Format_string - string expression of the special type\nExpression - arbitrary string expression.",
      "Description": "Format(Format_string, Expression [, ... Expression])",
      "Output": "Returns the list of expressions in the given format.\nFormat_string is represented below:\n       [String] %s [String] [... [[String]%s[String]]]\n       String - string expression\n       %s - character that is replaced by another Expression from the list."
    },
    "Frac": {
      "Arguments": "Argument - numeric expression.",
      "Description": "Frac(Argument)",
      "Output": "Returns the fractional part of the Argument."
    },
    "Hour": {
      "Arguments": "DateTime - a Date\/Time type argument.",
      "Description": "Hour(DateTime)",
      "Output": "Returns the hour according to the specified date\/time."
    },
    "HoursBetween": {
      "Arguments": "Date1, Date2 - Date\/Time type arguments.\nAbsolute_Value - an optional boolean parameter.",
      "Description": "HoursBetween(Date1, Date2[, Absolute_Value = True])",
      "Output": "Returns the number of complete hours between two dates.\nIf Date2 is earlier than Date1 and Absolute_Value = False, the function will return the negative number of complete time spans between the dates; if Absolute_Value = True, the function will return the absolute value"
    },
    "IF": {
      "Arguments": "Antecedent - logical expression;\nValue1,\nValue2 - expressions of any types",
      "Description": "IF(Antecedent, Value1, Value2)",
      "Output": "Returns Value1 if the Antecedent is true or Value2 if it is false. The function result has the variant type"
    },
    "IFF": {
      "Arguments": "Antecedent - logical expression;\nValue1,\nValue2 - numeric expressions or expressions of the Date\/time type",
      "Description": "IFF(Antecedent, Value1, Value2)",
      "Output": "Returns Value1 if the Antecedent is true or Value2 if it is false."
    },
    "IN": {
      "Arguments": "Value - value of the target element;\nElement1,\nElement2,\nElementN - values of the list elements",
      "Description": "N(Value, Element1, Element2, ..., ElementN)",
      "Output": "Function returns the True value of the logical type if the Value is in the list, otherwise the result is False."
    },
    "Int": {
      "Arguments": "Argument - numeric expression.",
      "Description": "Int(Argument)",
      "Output": "Returns the integer part of the Argument."
    },
    "IsInfinite": {
      "Arguments": "Argument - numeric expression;",
      "Description": "IsInfinite(Argument)",
      "Output": "Determines whether the transferred value is an infinite number."
    },
    "IsNull": {
      "Arguments": "Argument - any expression;",
      "Description": "IsNull(Argument)",
      "Output": "Checks whether the Argument is null. Returns the logical value."
    },
    "ISO8601ToDate": {
      "Arguments": "Argument - the string expression containing date\/time in ISO 8601 format",
      "Description": "ISO8601ToDate(Argument)",
      "Output": "Function converts the string containing date\/time in ISO 8601 format into the \"Date\/Time\" value type.\nIn the context of the specified time offset with regard to UTC, the date\/time is set to the current time zone.\nIf the time offset is not specified, the date\/time remains unchanged."
    },
    "Left": {
      "Arguments": "String - expression of the string type.",
      "Description": "Left(String, Count_of_characters)",
      "Output": "Returns the given count of characters of the left string part."
    },
    "LevDist": {
      "Arguments": "String1,\nString2 - expressions of the string type.",
      "Description": "LevDist(String1, String2)",
      "Output": "The function returns the Levenshtein distance for strings String1, String2. The Levenshtein distance is an edit distance, a metric of similarity between two strings. The value returned is the minimum number of operations (consisting of insertions, deletions or substitutions of a single character) required to change one string into the other."
    },
    "Ln": {
      "Arguments": "Argument - positive numeric expression.",
      "Description": "Ln(Argument)",
      "Output": "Returns the natural argument logarithm."
    },
    "Log": {
      "Arguments": "Basis - numeric expression;\nArgument - positive numeric expression.",
      "Description": "Log(Basis, Argument)",
      "Output": "Returns the argument logarithm with the given basis."
    },
    "Lower": {
      "Arguments": "Argument - string expression.",
      "Description": "Lower(Argument)",
      "Output": "Returns the lowercase argument."
    },
    "Max": {
      "Arguments": "Argument1,\nArgument2,\n... - numeric expressions.",
      "Description": "Max(Argument1, Argument2 ...)",
      "Output": "Returns the maximum argument."
    },
    "MillisecondsBetween": {
      "Arguments": "Date1, Date2 - Date\/Time type arguments.\nAbsolute_Value - an optional boolean parameter.",
      "Description": "MillisecondsBetween(Date1, Date2[, Absolute_Value = True])",
      "Output": "Returns the number of complete milliseconds between two dates.\nIf Date2 is earlier than Date1 and Absolute_Value = False, the function will return the negative number of complete time spans between the dates; if Absolute_Value = True, the function will return the absolute value"
    },
    "Min": {
      "Arguments": "Argument1,\nArgument2,\n... - numeric expressions.",
      "Description": "Min(Argument1, Argument2 ...)",
      "Output": "Returns the minimum argument."
    },
    "Minute": {
      "Arguments": "DateTime - a Date\/Time type argument.",
      "Description": "Minute(DateTime)",
      "Output": "Returns minutes according to the specified date\/time."
    },
    "MinutesBetween": {
      "Arguments": "Date1, Date2 - Date\/Time type arguments.\nAbsolute_Value - an optional boolean parameter.",
      "Description": "MinutesBetween(Date1, Date2[, Absolute_Value = True])",
      "Output": "Returns the number of complete minutes between two dates.\nIf Date2 is earlier than Date1 and Absolute_Value = False, the function will return the negative number of complete time spans between the dates; if Absolute_Value = True, the function will return the absolute value"
    },
    "Mod": {
      "Arguments": "Dividend - integer numeric expression,\nDivisor - integer numeric expression.",
      "Description": "Mod(Dividend, Divisor)",
      "Output": "Returns remainder from integer division of the Dividend by the Divisor."
    },
    "Month": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "Month(Date)",
      "Output": "Returns the month according to the specified date."
    },
    "MonthsBetween": {
      "Arguments": "Date1, Date2 - Date\/Time type arguments.\nAbsolute_Value - an optional boolean parameter.",
      "Description": "MonthsBetween(Date1, Date2[, Absolute_Value = True])",
      "Output": "Returns the number of complete months between two dates.\nIf Date2 is earlier than Date1 and Absolute_Value = False, the function will return the negative number of complete time spans between the dates; if Absolute_Value = True, the function will return the absolute value"
    },
    "MovingAverage": {
      "Arguments": "Arguments - values of the numeric series",
      "Description": "MovingAverage(X{t}, X{t-1} ...)",
      "Output": "Used in user models for building a user model of a simple moving average.\n\nThe moving average formula:\nMA = (X(t) + ... + X(t - n))\/n. "
    },
    "Now": {
      "Arguments": "Arguments are absent.",
      "Description": "Now()",
      "Output": "Returns the current date and time.\nThe current date and time represent the time the expression gets calculated, and it is calculated each time the expression's value is retrieved, for example, when viewing results in a tabular form or exporting data. Thus, it is generally recommended to enable the \"Cache\" expression parameter when it is available."
    },
    "Null": {
      "Arguments": "Arguments are absent.",
      "Description": "Null()",
      "Output": "Function returns the null value."
    },
    "NVL": {
      "Arguments": "Expression - any string or numeric expression.\nDefault_value - optional parameter, string or numeric expression value of which is returned if the Expression is equal to Null.",
      "Description": "NVL(Expression [, Default_value = \"\"])",
      "Output": "Returns the Expression value if it is not equal to Null, and Default_value otherwise."
    },
    "NVLF": {
      "Arguments": "NumericExpression - the original expression, which can be a number or Null.\nValue_by_default - an optional parameter, a numeric expression, the value of which is returned if NumericExpression is Null.",
      "Description": "NVLF(NumericExpression [, Value_by_default = 0])",
      "Output": "Returns NumericExpression if it is not Null, else Value_by_default."
    },
    "Pi": {
      "Arguments": "Arguments are absent.",
      "Description": "Pi()",
      "Output": "Returns the pi constant value 3.1415926535897932385."
    },
    "Pow": {
      "Arguments": "Argument - numeric expression;\nDegree - numeric expression;",
      "Description": "Pow(Argument, Degree)",
      "Output": "Returns the argument in the given degree."
    },
    "Random": {
      "Arguments": "Arguments are absent.",
      "Description": "Random()",
      "Output": "Returns pseudorandom evenly distributed number larger or equal to 0 and less than 1.\nAs a random number will be generated each time when getting the expression value, for example, when viewing the result in tabular form or executing data export, it is generally recommended to enable the \"Cache\" expression parameter if it is available."
    },
    "RelErr": {
      "Arguments": "Arguments - any numeric expressions.",
      "Description": "RelErr(Argument1, Argument2)",
      "Output": "Returns the relative error of two arguments."
    },
    "Repeat": {
      "Arguments": "String - string expression.\nCount_of_repeats - integer",
      "Description": "Repeat(String, Count_of_repeats)",
      "Output": "Returns a string - repeating the given string as many times as necessary."
    },
    "Replace": {
      "Arguments": "String - the string in which a replacement is required;\nOld_template - the replaced substring;\nNew_template - the string with which the Old template will be replaced;\nReplace_all - flag of replacement of all occurrences of the Old template with the New template. Argument of the logical type;\nIgnore_case - flag of case sensitivity in case of replacement. Argument of the logical type.",
      "Description": "Replace(String, Old_template, New_template [, Replace_all, Ignore_case])",
      "Output": "The function returns the String where occurrences of the Old Template have been substituted with the New Template.\n If the \"Replace all\" flag is True, all occurrences of the Old Template will be replaced with the New Template in the returned string.\n If \"Replace all\" is False, only the first occurrence will be replaced.\n If the \"Ignore case\" flag is True, the search for the fragments to replace (the Old Template) will be case-insensitive.\n If \"Ignore case\" is False, the search for the Old Template will be case-sensitive.\nThe last two parameters may be not specified.\n If \"Ignore case\" is not specified, the search will be case-sensitive.\n If \"Replace all\" is not specified, only the first occurrence of the Old Template will be replaced.\n For example, Replace(\"A000a00A\", \"A\", \"B\", True, True) returns \"B000B00B\" (all occurrences of string \"A\" replaced with string \"B\", ignoring case).\n Replace(\"A000a00A\", \"A\", \"B\", True, False) returns \"B000a00B\".\n Replace(\"A000a00A\", \"A\", \"B\") returns \"B000a00A\"."
    },
    "Right": {
      "Arguments": "String - expression of the string type.",
      "Description": "Right(String, Count_of_characters)",
      "Output": "Returns the given count of characters of the right string part."
    },
    "Round": {
      "Arguments": "Argument1 - numeric expression,\nArgument2 - optional parameter, the number of digits following the decimal point, integer.",
      "Description": "Round(Argument1 [, Argument2 = 0])",
      "Output": "Rounds a real number to a given decimal place."
    },
    "RoundDown": {
      "Arguments": "Argument1 - numeric expression,\nArgument2 - optional parameter, the number of digits following the decimal point, integer.",
      "Description": "RoundDown(Argument1 [, Argument2 = 0])",
      "Output": "Rounds a real number down to a given decimal place."
    },
    "RoundUp": {
      "Arguments": "Argument1 - numeric expression,\nArgument2 - optional parameter, the number of digits following the decimal point, integer.",
      "Description": "RoundUp(Argument1 [, Argument2 = 0])",
      "Output": "Rounds a real number up to a given decimal place."
    },
    "Second": {
      "Arguments": "DateTime - a Date\/Time type argument.",
      "Description": "Second(DateTime)",
      "Output": "Returns seconds according to the specified date\/time."
    },
    "SecondsBetween": {
      "Arguments": "Date1, Date2 - Date\/Time type arguments.\nAbsolute_Value - an optional boolean parameter.",
      "Description": "SecondsBetween(Date1, Date2[, Absolute_Value = True])",
      "Output": "Returns the number of complete seconds between two dates.\nIf Date2 is earlier than Date1 and Absolute_Value = False, the function will return the negative number of complete time spans between the dates; if Absolute_Value = True, the function will return the absolute value"
    },
    "Sign": {
      "Arguments": "Argument - numeric expression;",
      "Description": "Sign(Argument)",
      "Output": "Returns the argument sign."
    },
    "Sin": {
      "Arguments": "Angle - angle value in radians.",
      "Description": "Sin(Angle)",
      "Output": "Returns the sine of the set angle."
    },
    "Space": {
      "Arguments": "Count_of_spaces - integer.",
      "Description": "Space(Count_of_spaces)",
      "Output": "Returns the given count of spaces."
    },
    "Sqrt": {
      "Arguments": "Argument - positive numeric expression.",
      "Description": "Sqrt(Argument)",
      "Output": "Returns the square root of the argument."
    },
    "StartOfInterval": {
      "Arguments": "Date - a Date\/Time type argument.\nInterval_Count - the number of the given type intervals included in the interval; a positive integer number.\nInterval_Type - the type of the time interval.\nStarting_Point - a Date\/Time argument with which the counting of time intervals starts.\nInterval_Type can assume the following values:\n \"Year\" - the interval is set in years (starting with year 0 by default);\n \"Quarter\" - the interval is set in quarters (starting with the first quarter of year 1 by default);\n \"Month\" - the interval is set in months (starting with January of year 1 by default);\n \"Week\" - the interval is set in weeks (starting with January 1, 1900 by default);\n \"Day\" - the interval is set in days (starting with December 30, 1899 by default);\n \"Hour\" - the interval is set in hours (starting with 00:00 December 30, 1899 by default);\n \"Minute\" - the interval is set in minutes (starting with 00:00 December 30, 1899 by default);\n \"Second\" - the interval is set in seconds (starting with 00:00 December 30, 1899 by default).",
      "Description": "StartOfInterval(Date, Interval_Count, Interval_Type[, Starting_Point])",
      "Output": "The function returns the beginning of a specified time interval.\nThe interval's length is defined by the parameters Interval_Type and Interval_Count.\nIf the Starting_Point parameter is set, the intervals are counted starting with the beginning of the interval to which the Starting_Point belongs.\nFor example, if Interval_Type is month and Starting_Point is November 15, 2023, the intervals will be calculated starting from November 1, 2023"
    },
    "StartOfTheMonth": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "StartOfTheMonth(Date)",
      "Output": "The function returns the first date of the month specified in Date"
    },
    "StartOfTheQuarter": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "StartOfTheQuarter(Date)",
      "Output": "The function returns the first date of the quarter to which the specified Date belongs"
    },
    "StartOfTheWeek": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "StartOfTheWeek(Date)",
      "Output": "Function returns the date of the specified week start according to ISO 8601 standard subject to which the week starts from Monday and ends with Sunday."
    },
    "StartOfTheYear": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "StartOfTheYear(Date)",
      "Output": "The function returns the first date of the year specified in Date"
    },
    "StdDev": {
      "Arguments": "Arguments - any numeric expressions.",
      "Description": "StdDev(Argument1, Argument2 ...)",
      "Output": "Returns the standard deviation of arguments."
    },
    "Str": {
      "Arguments": "Argument - expression of the numeric type.",
      "Description": "Str(Argument)",
      "Output": "Returns a locale-aware string representation of the Argument."
    },
    "StrToDate": {
      "Arguments": "Argument - the string expression containing date\/time\nFormat - optional parameter date\/time format in terms of D, M, Y, H, N, S, Z",
      "Description": "StrToDate(Argument [, Format])",
      "Output": "Function converts the string containing the date into the \"Date\/Time\" format.\nThe format examples:\n  \"DD.MM.YY\" - defines that the Argument contains strings of the following type: \"25.12.04\";\n  \"DD\/MM\/YY HH:NN:SS\" - defines that the Argument contains strings of the following type: \"25\/12\/04 12:44:54\";"
    },
    "StrZero": {
      "Arguments": "Expression - numeric expression.\nTotal_length - length of the resulting string",
      "Description": "StrZero(Expression, Total_length)",
      "Output": "Adds zeros at the front of the specified expression so that the resulting string length is equal to the Total_length."
    },
    "Stuff": {
      "Arguments": "Source - string expression.\nInserted_string - string expression.\nStart - position of the insert start\nLength - length of the deleted substring",
      "Description": "Stuff(Source, Start, Length [, Inserted_string = \"\"])",
      "Output": "Returns the string of the following type. At first, substring is deleted from the Source, starting from the Start position of the Length length. Then instead of the deleted substring, the Inserted_string is inserted."
    },
    "SubStr": {
      "Arguments": "Source - string expression.\nStart - position of the substring start\nLength - the substring length",
      "Description": "SubStr(Source, Start, Length)",
      "Output": "Returns substring from string - source, starting from the Start position of the Length length."
    },
    "Sum": {
      "Arguments": "Arguments - any numeric expressions.",
      "Description": "Sum(Argument1, Argument2 ...)",
      "Output": "Returns the sum of arguments."
    },
    "SumSq": {
      "Arguments": "Arguments - any numeric expressions.",
      "Description": "SumSq(Argument1, Argument2 ...)",
      "Output": "Returns the sum of squared arguments."
    },
    "Tan": {
      "Arguments": "Angle - angle value in radians.",
      "Description": "Tan(Angle)",
      "Output": "Returns the tangent of the set angle."
    },
    "Today": {
      "Arguments": "Arguments are absent.",
      "Description": "Today()",
      "Output": "Returns the current date.\nThe current date is the date the expression gets calculated, and it is calculated each time the expression's value is retrieved, for example, when viewing results in a tabular form or exporting data. Thus, it is generally recommended to enable the \"Cache\" expression parameter when it is available."
    },
    "Trim": {
      "Arguments": "Argument - string expression.",
      "Description": "Trim(Argument)",
      "Output": "Returns the Argument without leading and trailing spaces."
    },
    "TrimLeft": {
      "Arguments": "Argument - string expression.",
      "Description": "TrimLeft(Argument)",
      "Output": "Returns the Argument without leading spaces."
    },
    "TrimRight": {
      "Arguments": "Argument - string expression.",
      "Description": "TrimRight(Argument)",
      "Output": "Returns the Argument without trailing spaces."
    },
    "UnixToDateTime": {
      "Arguments": "UnixTime - integer number of seconds elapsed since 1970-01-01T00:00:00Z;\nReturn_In_UTC - an optional boolean parameter.",
      "Description": "UnixToDateTime(UnixTime[, Return_In_UTC = True])",
      "Output": "Returns date and time according to the specified Unix time.\nIf Return_In_UTC = False, the result of the function call will be based on local time."
    },
    "Upper": {
      "Arguments": "Argument - string expression.",
      "Description": "Upper(Argument)",
      "Output": "Returns the uppercase argument."
    },
    "Val": {
      "Arguments": "String - a string expression.\nDecimal_Separator - an optional string parameter used to separate the integer part of a number from the fractional part. By default, the convertion is made using the decimal separator of the current pckage locale. Decimal_Separator must be one character long.\nThousands_Separator - an optional parameter of string or boolean types used to separate digit groups in large numbers. If Thousands_Separator is of a string type, it must be one character long.",
      "Description": "Val(String[, Decimal_Separator, Thousands_Separator = True])",
      "Output": "Converts the specified string to a number using the Decimal_Separator and Thousands_Separator parameters.\nIf Thousands_Separator is not specified of is True, the string is converted using the thousands separator specified in the current package locale. If Thousands_Separator is False, the convertion does not employ thousands separators.\nThe Decimal_Separator and Thousands_Separator parameters may be any ASCII characters except numbers, + and - characters and letter E. For Thousands_Separator, the NBSP character is also acceptable.\nIn case the Decimal_Separator and Thousands_Separator parameters are set, their values must not be the same.\nIf only the Decimal_Separator parameter is set, it must differ from the thousands separator specified in the current package locale."
    },
    "Week": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "Week(Date)",
      "Output": "Returns the number of the given date's week within the year following the ISO 8601 standard, under which weeks start on Monday and end on Sunday. The first week of the year is the first week in the Gregorian calendar which includes a Thursday."
    },
    "Year": {
      "Arguments": "Date - a Date\/Time type argument.",
      "Description": "Year(Date)",
      "Output": "Returns the year according to the specified date."
    },
    "YearsBetween": {
      "Arguments": "Date1, Date2 - Date\/Time type arguments.\nAbsolute_Value - an optional boolean parameter.",
      "Description": "YearsBetween(Date1, Date2[, Absolute_Value = True])",
      "Output": "Returns the number of complete years between two dates.\nIf Date2 is earlier than Date1 and Absolute_Value = False, the function will return the negative number of complete time spans between the dates; if Absolute_Value = True, the function will return the absolute value"
    }
  },
  "RegExFunctions": {
    "RegExDomain": {
      "Arguments": "InputString - the input string in which the domain name will be searched;\nOccurrenceNumber - the index of the domain name in the searched string.",
      "Description": "RegExDomain(InputString [, OccurrenceNumber = 1])",
      "Output": "Returns the OccurrenceNumber-th domain name in the InputString, up to the top level domain, inclusively, not including www.\nRegular expressions are used for the search."
    },
    "RegExEmail": {
      "Arguments": "InputString - the input string in which the email address will be searched;\nOccurrenceNumber - the index of the email address in the searched string.",
      "Description": "RegExEmail(InputString [, OccurrenceNumber = 1])",
      "Output": "Retrieves the OccurrenceNumber-th email address from the InputString.\nRegular expressions are used for the search."
    },
    "RegExMatch": {
      "Arguments": "RegularExpression - the regular expressions string;\nString - the input string.",
      "Description": "RegExMatch(RegularExpression, String)",
      "Output": "Checks if the string matches the regular expression.\nThe PCRE2 library is used. Syntax and semantics are compatible with Perl regular expressions."
    },
    "RegExMatchCount": {
      "Arguments": "RegularExpression - the regular expressions string;\nString - the input string.",
      "Description": "RegExMatchCount(RegularExpression, String)",
      "Output": "Returns the number of the string parts matching the regular expression.\nPCRE2 library is used. Syntax and semantics are compatible with the Perl regular expressions."
    },
    "RegExMatchedExp": {
      "Arguments": "RegularExpression - the regular expression string;\nString - the input string;\nMatchIndex - the index of the matched substring. The parameter must be within the range from 1 to RegExMatchCount.",
      "Description": "RegExMatchedExp(RegularExpression, String [, MatchIndex = 1])",
      "Output": "Returns the string part matching the regular expression.\nPCRE2 library is used. Syntax and semantics are compatible with the Perl regular expressions."
    },
    "RegExMatchedNamedSubExp": {
      "Arguments": "RegularExpression - the regular expression string;\nString - the input string;\nGroupName - the name of the group defined by metacharacters (...);\nMatchIndex - the index of the matched substring. The parameter must be within the range from 1 to RegExMatchCount.",
      "Description": "RegExMatchedNamedSubExp(RegularExpression, String, GroupName [, MatchIndex = 1])",
      "Output": "Returns the named string part group matching the regular expression.\nPCRE2 library is used. Syntax and semantics are compatible with the Perl regular expressions."
    },
    "RegExMatchedSubExp": {
      "Arguments": "RegularExpression - the regular expression string;\nString - the input string;\nGroupIndex - the index of the group defined by metacharacters (...);\nMatchIndex - the index of the matched substring. The parameter must be within the range from 1 to RegExMatchCount.",
      "Description": "RegExMatchedSubExp(RegularExpression, String, GroupIndex [, MatchIndex = 1])",
      "Output": "Returns the string part group matching the regular expression.\nGroups are numbered from left to right according to occurrence of opening brackets.\nPCRE2 library is used. Syntax and semantics are compatible with the Perl regular expressions."
    },
    "RegExReplace": {
      "Arguments": "RegularExpression - the regular expression string;\nInputString - the input string that will be replaced;\nReplaceString - the string that will be inserted instead of the input string part matching the regular expression;\nMatchIndex - the index of the matched substring. The parameter must be within the range from 1 to RegExMatchCount..\nExtendedSyntax - extended replacement syntax (The PCRE2 library is used).",
      "Description": "RegExReplace(RegularExpression, InputString, ReplaceString [, MatchIndex = 1, ExtendedSyntax = False])",
      "Output": "Returns the InputString in which the MatchIndex-th occurrence of the RegularExpression will be replaced with the ReplaceString.\nThe PCRE2 library is used. Syntax and semantics are compatible with Perl regular expressions."
    },
    "RegExReplaceAll": {
      "Arguments": "RegularExpression - the regular expression string;\nInputString - the input string that will be replaced;\nReplaceString - the string that will be inserted instead of the input string parts matching the regular expression;\nExtendedSyntax - extended replacement syntax (The PCRE2 library is used).",
      "Description": "RegExReplaceAll(RegularExpression, InputString, ReplaceString [, ExtendedSyntax = False])",
      "Output": "Returns the InputString in which all occurrences of the RegularExpression expression will be replaced with the ReplaceString.\nPCRE2 library is used. Syntax and semantics are compatible with the Perl regular expressions."
    }
  },
  "StatFunctions": {
    "DKhi2": {
      "Arguments": "Degrees_of_freedom - the number of the degrees of freedom.\nArgument - the value for which the probability density should be calculated.",
      "Description": "DKhi2(Degrees_of_freedom, Argument)",
      "Output": "The density function of the chi-square gamma distribution. The function returns probability density."
    },
    "FKhi2": {
      "Arguments": "Degrees_of_freedom - the number of the degrees of freedom.\nArgument - the value for which the probability should be calculated.",
      "Description": "FKhi2(Degrees_of_freedom, Argument)",
      "Output": "The chi-square distribution function. Returns the left-sided probability of chi-square distribution P(X <= Argument)."
    },
    "InvKhi2": {
      "Arguments": "Degrees_of_freedom - the number of the degrees of freedom.\nProbability - the value of the chi-square distribution function.",
      "Description": "InvKhi2(Degrees_of_freedom, Probability)",
      "Output": "The inverse chi-square distribution function. Returns the threshold value x, for which the probability function takes the value Probability. If p=FKhi2(N, x), then InvKhi2(N, p) = x."
    },
    "PKhi2": {
      "Arguments": "Degrees_of_freedom - the number of the degrees of freedom.\nArgument - the value for which the probability should be calculated.",
      "Description": "PKhi2(Degrees_of_freedom, Argument)",
      "Output": "An additional chi-square distribution function. Returns the right-sided probability of chi-square distribution P(X > Argument)."
    }
  },
  "TreeFunctions": {
    "DisplayName": {
      "Arguments": "NodePath - the path to a node, variable or expression",
      "Description": "DisplayName([\"NodePath\"])",
      "Output": "The function returns the caption (display name) based on the path to a node, variable or expression.\nIf the function is activated without arguments, it returns the caption of the expression being currently computed.\nNote: NodePath is a string value, so an explicitely specified NodePath must be in quotes.\nFor example: DisplayName(\"Root.Node1\")"
    },
    "ItemCount": {
      "Arguments": "Arguments are absent.",
      "Description": "ItemCount()",
      "Output": "The function returns the number of expressions within an array."
    },
    "ItemIndex": {
      "Arguments": "Arguments are absent.",
      "Description": "ItemIndex()",
      "Output": "The function returns the index of an expression within an array. The numbering starts with 0."
    },
    "Location": {
      "Arguments": "Arguments are absent.",
      "Description": "Location()",
      "Output": "The function returns the path from the tree root to the expression."
    },
    "Parent": {
      "Arguments": "Arguments are absent.",
      "Description": "Parent()",
      "Output": "The function returns the parent node of the expression's current node."
    }
  },
  "VariablesFunctions": {
    "DisplayName": {
      "Arguments": "VariableName - the name of a variable or an expression",
      "Description": "DisplayName([\"VariableName\"])",
      "Output": "The function returns the caption (display name) based on the name of a variable or an expression.\nIf the function is activated without arguments, it returns the caption of the expression being currently computed.\nNote: VariableName is a string value, so an explicitely specified VariableName must be in quotes.\nFor example: DisplayName(\"VAR1\")"
    }
  }
}